<head>
  <link rel="stylesheet" href="css/left-panel.css" media="all">
  <link rel="stylesheet" href="css/up-panel.css" media="all">
  <link rel="stylesheet" href="css/fieldset.css" media="all">
  <link rel="stylesheet" href="css/right-click-menu.css" media="all">
  <link rel="stylesheet" href="css/buttons-and-menus.css" media="all">
</head>
<div class="left-top-panel">
  <button disabled class="b-1" id="last-action-time"
    style="color: black;z-index:1; position: absolute;top: 50%;left: 50%; transform: translate(-50%, -50%);">⏳</button>
</div>

<div class="left-side-panel">
  <div id="nav-buttons">
    <a href="https://webdev983.github.io/templatesv3/summary"><button class="b-1">🧠</button></a>
    <a href="https://webdev983.github.io/templatesv3/files"><button class="b-1">📂</button></a>
  </div>
  <div style="margin-top: 30px;">
    <button class="b-1 " id="toggle-component-tree" onclick="toggleComponentTree()">🧩</button>
    <button class="b-1 " id="toggle-code-tree" onclick="toggleCodeTree()">🏷️</button>
    <button class="b-1 " id="toggle-head" onclick="toggleHead()">🗿</button>
    <button class="b-1 " id="toggle-generated-page" onclick="toggleGeneratedPage()">👁️</button>
  </div>
  <div id="logs-menu">
    <button class="b-1 b-select" id="log-open">🪵</button>
  </div>
  <table id="code-log" class="table-1" hidden style="margin-bottom: 100px;">
    <button hidden id="refresh-page" class="b-1">🔄</button>
    <thead>
      <tr>
        <th style="text-align: left;">🕓time</th>
        <th style="text-align: left;">✔️action</th>
      </tr>
    </thead>
    <tbody id="code-log-body">
      <tr hidden id="code-log-element">
        <td data-type-code-log="action-time"><span id="code-log-action-time">1703707728031</span></td>
        <td data-type-code-log="action-name"><span id="code-log-action">append child</span></td>
        <td><button data-type-code-log="action-remove" onclick="deleteAction(event)" class="b-5">&#128465;</button></td>
      </tr>
    </tbody>
  </table>
</div>

</div>
<div id="bottom-buttons" class="bottom-buttons">
  <button class="b-1">📴</button>
</div>



<div id="content-grid" style="display: grid; grid-template-columns: 100% 0%;">
  <main id="main-content" style="margin-left:80px; margin-top: -60" class="main-content">
    <div id="web-page-menu" class="on-page-menu">
      <label class="l-1" style="margin-right: 10px; user-select: none;">🌐</label>
      <button class="b-1" style="margin-right: 5px;">🖼️</button>
      <button class="b-1" style="margin-right: 5px;">🔄</button>
      <button class="b-1" style="margin-right: 5px;">🗑</button>
    </div>



    <div class="up-panel">
      <button id="path-icon" class='b-1' onclick="publish(event)" style="user-select: none;">🧩</button><label
        id="page-path" class="l-2" style="cursor: pointer; color:#4A90E2;">~</label>
      <a href="" target="_blank" style="text-decoration: none; color: #000000;" hidden id="published-label"
        class="l-3">🌐</a>
    </div>

    <div id="code-builder" style="position: relative;">
      <div id="components-tree-menu" class="on-page-menu">
        <label class="l-1" style="margin-right: 10px; user-select: none;">🧩</label>
        <button class="b-1" style="margin-right: 5px;" onclick="addComponent(event)">➕</button>
      </div>

      <div id="components-tree" style="position: relative; margin-left: 10px;">
      </div>

      <div id="code-tree-menu" class="on-page-menu">
        <label class="l-1" style="margin-right: 10px; user-select: none;">🏷️</label>
        <button class="b-1" onclick="addTreeElement(event)">➕</button>
      </div>
      <div id="code-tree" style="position: relative; margin-left: 10px;">
        <fieldset id="head-tree" data-element="code-tree-tag" class="tree-element">
          <legend>💬</legend>
          <input id="selectedCheckbox" hidden="" type="checkbox" onchange="handleCheckboxChange(event)">
          <button class="b-3 arrow" data-element="code-tree-show-hide-button"
            onclick="toggleSubFields(event)">→</button>
          <button class="b-3 t" data-element="code-tree-tag-name-button"
            onclick="loader(event, handleTreeClick)">🏷️head</button>
          <button class="b-3 t" data-element="code-tree-inner-html-button" onclick="openInnerHtmlContent(event)">
            ▶️</button>
          <button class="b-3 t" data-element="code-tree-attributes-button"
            onclick="openAttributeContent(event)">🔑</button>
          <button class="b-3 t" data-element="code-tree-text-content-button"
            onclick="openTextContent(event)">📄</button>
          <div data-open-menu></div>
        </fieldset>

        <fieldset id="body-tree" data-element="code-tree-tag" class="tree-element">
          <legend>💬</legend>
          <input id="selectedCheckbox" hidden="" type="checkbox" onchange="handleCheckboxChange(event)">
          <button class="b-3 arrow" data-element="code-tree-show-hide-button"
            onclick="toggleSubFields(event)">→</button>
          <button class="b-3 t" data-element="code-tree-tag-name-button"
            onclick="loader(event, handleTreeClick)">🏷️body</button>
          <button class="b-3 t " data-element="code-tree-inner-html-button" onclick="openInnerHtmlContent(event)">
            ▶️</button>
          <button class="b-3 t" data-element="code-tree-attributes-button"
            onclick="openAttributeContent(event)">🔑</button>
          <button class="b-3 t" data-element="code-tree-text-content-button"
            onclick="openTextContent(event)">📄</button>
          <div data-open-menu></div>
        </fieldset>


      </div>


      <!--menus-->
    
      <div id="head-menu" class="on-page-menu">
        <label class="l-1" style="margin-right: 10px; user-select: none;">🗿</label>
      </div>
      <label id="checkbox-label" hidden data-type="dependant" class="l-3"><input type="checkbox">Color</label>
      <fieldset hidden id="dependee-menu-item" data-type="dependee">
        <legend>
          <label class="l-2">🎚️</label>
          <label data-type="dependee-value" class="l-2 b-dark-blue">Price</label>
        </legend>

        <div>
          <button class="b-3" id="generate-dependees" onclick="generateDependees(event)">Generate</button>
        </div>
      </fieldset>
      <div id="head-1">
        <div style="margin-left: 15px;">

          <fieldset hidden id="breadCrumb-menu" class="menu">
            <legend><label class="l-2">🥖 BreadCrumb Menu</label></legend>
            <button class="b-3" onclick="generateBreadCrumb(event)"> Generate</button>
          </fieldset>



          <div hidden id=sku-item-1>
            <label class="l-3 b-dark-blue">SKU:</label><label class="l-2" id="sku-value"></label>
            <button class="b-3" id="toggleSkuAttributeList" onclick='toggleSkuAttributeList(event)'>👀</button>
            <button class="b-3" id="toggleDependencyMenu1" onclick='toggleDependencyMenu1(event)'>🛠️</button>


            <button class="b-3" id="remove-sku" onclick="openRemoveSku(event)">🗑</button>

            <fieldset style="display: none;" id="remove-sku-menu" class="menu">
              <legend><button class="b-6" onclick="cancel(event)" style="font-size: 0.9em;">❌</button></legend>
              <label class="l-3">Are you sure want to remove this SKU?</label>
              <br>
              <button onclick="removeSku(event)" class="b-3">🗑 Remove</button>
            </fieldset>

            <ul class="list-1" hidden id="sku-attribute-list">
              <div id='sku-item'>
                <li id="sku-attribute"><span class="l-4" id="sku-attribute-value">Solo</span></li>
              </div>
            </ul>

            <div id="dependee-menu" hidden>
              <fieldset data-type="dependee">
                <legend>
                  <label class="l-2">🎚️</label>
                  <label data-type="dependee-value" class="l-2 b-dark-blue">Price</label>
                </legend>
                <label data-type="dependant" class="l-3"><input type="checkbox">Color</label>
                <div>
                  <button class="b-3" id="generate-dependees">Generate</button>
                </div>
              </fieldset>
            </div>
          </div>
          <div id="sku-menu" hidden>
            <input type="text" class="b-3" id="input-sku" placeholder="enter sku">
            <button class="b-3" id="create-sku" onclick="addSku(event)">▶️</button>
            <div id="sku-list" hidden>


            </div>

          </div>
        </div>
      </div>

      <div id="generated-page-menu" class="on-page-menu">
        <label class="l-1" style="margin-right: 10px; user-select: none;">👁️</label>
        <button id='transform' class="b-1" onclick="transformToVisual(event)">✍️</button>
      </div>
      <!--      <div id="generated-page" style="margin-bottom: 200px;">
      </div>
-->

      <iframe id="generated-page-iframe" src="./iframe.html"
        style="width:100%; height:20000px; border:none; margin-bottom: 200px;" allowfullscreen="true" allow="
      
      display-capture;
      geolocation; 
      microphone; 
      web-share">
      </iframe>

  </main>


  <!-- MENUS-->
  <div hidden>

          
    <fieldset id="update-href-menu" class="menu" data-menu>
      <legend><button onclick="cancel(event)" class="b-6">❌</button></legend>
      <input id="editHrefInput" style="width: 500px" placeholder="🔗 edit href" type="text">
      <button id="editHrefButton">💾</button>
    </fieldset>


    <fieldset id="component-element" data-element="code-tree-tag" class="tree-element">
      <legend>💬</legend>
      <input hidden type="checkbox" onchange="handleCheckboxChange(event)">
      <button class="b-3 arrow" data-element="code-tree-show-hide-button"
        onclick="toggleSubFields(event)">&#8594;</button>
      <button class="b-3 t" data-element="code-tree-tag-name-button"
        onclick="loader(event, handleComponentClick)">🏷️component</button>
      <button class="b-3 t" data-element="code-tree-attributes-button" onclick="openAttributeContent(event)">🔑</button>
      <button hidden class="b-3 t" data-element="optional-script" onclick="replaceComponent(event,true)">🔄10</button>
      <span data-open-menu></button>
    </fieldset>

    <fieldset id="tree-element" data-element="code-tree-tag" class="tree-element">
      <legend>💬</legend>
      <input id="selectedCheckbox" hidden type="checkbox" onchange="handleCheckboxChange(event)">
      <button class="b-3 arrow" data-element="code-tree-show-hide-button"
        onclick="toggleSubFields(event)">&#8594;</button>
      <button class="b-3 t" data-element="code-tree-tag-name-button"
        onclick="loader(event, handleTreeClick)">🏷️component</button>
      <button class="b-3 t" data-element="code-tree-inner-html-button" onclick="openInnerHtmlContent(event)">
        ▶️</button>
      <button class="b-3 t" data-element="code-tree-attributes-button" onclick="openAttributeContent(event)">🔑</button>
      <button class="b-3 t" data-element="code-tree-text-content-button" onclick="openTextContent(event)">📄</button>
      <span data-open-menu></button>
    </fieldset>





    <!--menu click component-->
    <div id="code-tree-click-component" data-menu>
      <button class="b-3" onclick="cancel(event)">❌Cancel</button>
      <button style="margin-right: 5px; margin-top: 5px;" class="b-3" onclick="replaceComponent(event)">🔄
        Replace</button>
      <!-- <button style="margin-right: 5px; margin-top: 5px;" class="b-2" id="code-tree-click-tag-append-child" onclick="append(event)">👶 Append</button>
      <button style="margin-right: 5px; margin-top: 5px;" class="b-2" id="code-tree-click-tag-insert-before" onclick="insertB(event)">⬅️ InsertBefore</button>
        <button hidden class="b-2" id="code-tree-click-tag-remove-tag" onclick="removeComponent(event)">🗑 remove
          component</button> -->
    </div>


    <!--menu click tag-->
    <div id="code-tree-click-tag" data-menu>
      <button style="margin-right:5px; margin-top: 5px;" class="b-3" onclick="cancel(event)">❌</button>
      <br>
      <button style="margin-right:5px; margin-top: 5px;" class="b-3" id="code-tree-click-tag-append-child"
        onclick="append(event)">👶 Append</button>
      <button style="margin-right:5px; margin-top: 5px;" class="b-3" id="code-tree-click-tag-insert-before"
        onclick="insertB(event)">⬅️ InsertBefore</button>
      <br>
      <button style="margin-right:5px; margin-top: 5px;" class="b-3" id="code-tree-click-tag-change-tag"
        onclick="changeTagForCopies(event)">✏️ Change
        <button style="margin-right:5px; margin-top: 5px;" class="b-3" id="code-tree-click-tag-remove-tag"
          onclick="removeTagAndCopies(event)">🗑 Remove</button>
        <!--
      <button class="b-2" id="code-tree-click-tag-change-tag" onclick="changeTag(event)">✏️ Change tag</button>
          Copies</button>
        <button class="b-2" id="code-tree-click-tag-remove-tag" onclick="removeTag(event)">🗑 Remove
          element</button>
          <button  class="b-2" id="code-tree-click-tag-inner-html" onclick="insertHtml(event)">📄 inner HTML</button>
        <button class="b-2" id="code-tree-click-tag-dublicate-tag" onclick="duplicateTag(event)"> ⧉ Duplicate Element</button>
        -->
    </div>

    <!--menu add element-->
    <div id="code-tree-add-tag-step-1" style="padding: 7px;" data-menu>
      <button style="margin-bottom: 5px;" class="b-4" onclick="cancel(event)">❌</button>
      <br>
      <button class="b-4" id="code-tree-add-tag-choose-new" onclick="addNew(event)"> ➕ New</button>
      <button class="b-4" id="code-tree-add-tag-choose-existed" onclick="addExisting(event)"> ✔️ Existed</button>
    </div>


    <!-- menu confirm selected append/insert tags-->
    <div id="code-tree-append-or-insert-approv-menu" style="user-select: none;" data-menu>
      <button onclick="cancel(event)" class="b-4" style="margin-bottom: 5px; margin-top: 5px;">❌</button>
      <br>
      <span id="code-tree-amount-selected-for-append-or-insert" class="l-3">0</span>
      <button class="b-4" id="code-tree-click-tag-approve" onclick="approve(event)"> ✅ APPROVE</button>
      <label>⚠️<input id="code-tree-menu-dublicate-with-parent-option" type="checkbox">Duplicate with Parent</label>
    </div>




    <!-- menu to receive text area html -->
    <div id="code-tree-tag-text-content-form" data-menu>
      <button id="code-tree-tag-attributes-form-action-back" class="b-3" onclick="cancel(event)"
        style="margin-bottom:7px; margin-right: 5px;">❌</button>
      <button id="code-tree-tag-text-content-action-save" onclick="saveText(event)" class="b-3"
        style="margin-bottom:7px; margin-right: 5px;">💾 Save</button>
      <br>
      <textarea class="text1" placeholder=" 📄 Text content" id="code-tree-tag-text-content"></textarea>
      <br>
      <button id="code-tree-tag-text-content-action-save" onclick="saveText(event)" class="b-3"
        style="margin-top: 5px;">💾 save</button>
    </div>
    <!-- menu to receive inner html -->
    <div id="code-tree-tag-html-content-form" data-menu>
      <br>
      <button id="code-tree-tag-attributes-form-action-back" class="b-3" onclick="cancel(event)"
        style="margin-bottom:7px; margin-right: 5px;">❌</button>
      <button id="code-tree-tag-text-content-action-save" onclick="saveInnerHtml(event)" class="b-3"
        style="margin-bottom:7px; margin-right: 5px;">💾
        Save</button>
      <br>
      <textarea class="text1" placeholder=" ▶️ HTML content" id="code-tree-tag-html-content"></textarea>
      <br>
      <button id="code-tree-tag-text-content-action-save" onclick="saveInnerHtml(event)" class="b-3"
        style="margin-top:5px;">💾
        save</button>
    </div>



    <!--menu to view and edit attributes-->
    <div class="menu-1" id="code-tree-tag-attributes-form-1" data-menu>
      <button id="code-tree-tag-attributes-form-action-back" class="b-3" onclick="cancel(event)"
        style="margin-top: 10px; margin-bottom: 5px;">❌</button>
      <table class="table-2 table-row-number-2" id="code-tree-tag-attributes-list">
        <tbody>
          <tr id="code-tree-tag-attributes-list-item">
            <td><span class="l-4" style="user-select: none;">🔑</span><span class="l-4"
                id="code-tree-tag-attribute-key"></span></td>
            <td><span class="l-4" style="user-select: none;">📄</span><span class="l-4"
                id="code-tree-tag-attribute-value"><span></td>
            <td><button onclick="removeAttributeFromCopies(event)" class="b-4">🗑</button>
              <!-- <button id="code-tree-tag-attribute-remove-button" class="b-4"  onclick="removeAttribute1(event)">🗑</button> -->
            </td>
          </tr>
        </tbody>
      </table>
      <div style="margin-bottom: 10px;">
        <button class="b-3" onclick="saveAttribute(event)" style="margin-bottom: 5px; margin-top: 5px;">💾 Save</button>
        <br>
        <textarea id="code-tree-tag-attribute-input-text" class="text1" placeholder=" 🔑 Add Attributes"></textarea>
        <br>
        <button class="b-3" onclick="saveAttribute(event)" style="margin-bottom: 5px; margin-top: 5px;">💾 Save</button>
      </div>
    </div>

    <fieldset id="tag-table" style="border-width: 0px;" data-menu>
      <button onclick="cancel(event)" class="b-3" style="margin-top: 5px; margin-bottom: 5px;">❌</button></legend>
      <table id="tagsTable" class="tagsTable-style">
        <thead>
          <tr>
            <th><input type="text" id="searchTagName" placeholder="Search by Tag Name" onkeyup="filterTable(0)">
            </th>
            <th><input type="text" id="searchTagValue" placeholder="Search by Tag Value" onkeyup="filterTable(1)">
            </th>
            <th><input type="text" id="searchTagType" placeholder="Search by Tag Type" onkeyup="filterTable(2)">
            </th>
            <th><input type="text" id="searchTagComment" placeholder="Search by Tag Comment" onkeyup="filterTable(3)">
            </th>
          </tr>
          <tr>
            <th>Tag Name</th>
            <th>Tag Value</th>
            <th>Tag Type</th>
            <th>Tag Comment</th>
          </tr>
        </thead>
        <tbody>
        </tbody>
      </table>
    </fieldset>


    <!--files menus-->
    <!-- file path-->
    <li data-element="file-path" id="item">
      <label hidden class="l-3" style="margin-right: 3px;" id="Pushpin">📌</label>
      <label data-value="file-path" class="l-3">universal/blablabla/blablabla/coolcss</label>
      <label data-value="file-emoji" style="user-select: none; margin-left: 5px;" class="l-3">🧩</label>
      <div hidden data-value="file-id">for javascript</div>
      <button hidden data-action="remove-file-confirmation">for javascript</button>
    </li>


    <ol data-element="file-path-list" id="selectedFilePathList" class="list-1" style="margin-left: -10px;" data-menu>
      <button style="margin-bottom: 8px; margin-left: -10px;" class="b-4" onclick="cancelReplace(event)">❌Cancel</button>
      <button style="margin-bottom: 8px; margin-left: 4px;" class="b-4" onclick="approveReplace(event)">✅
        Approve</button>
      <button style="margin-bottom: 8px; margin-left: 4px;" class="b-4" data-action="moveBack">⤴️ Up</button>
    </ol>


    <ol id="filePathList" class="list-1" style="margin-left: -10px;">
    </ol>


    <div hidden id="file-list-attach-component-options" style="padding: 5px; margin-left: 10px;" data-menu>

      <button class="b-3" id="file-list-link-by-path" style="margin-top: 5px;" onclick="switchSelected(event)">*📁 By
        Path</button>
      <button class="b-3" id="file-list-link-by-name" style="margin-top: 5px;" onclick="switchSelected(event)">*🛖 By
        Name</button>
      <br>
      <button style="margin-top: 5px;" class="b-4" onclick="cancelReplace(event)">❌Cancel</button>
      <button style="margin-top: 5px;" class="b-4" onclick="approveAddComponent(event)">✅ Approve</button>
      <button style="margin-top: 5px;" class="b-4" data-action="moveBack">⤴️ Up</button>
    </div>
  </div>



  <div id="loading"
    style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); display: none; justify-content: center; align-items: center; z-index: 2;">

    <span style="font-size: 10.2em; color: white;">⏳</span>
    <div id="timer" style="font-size: 2em; color: white;">1.12</div>
    <button style="font-size: 30px;" id="remove-loading">❌</button>
  </div>

  <script>
    const urlSearchParams = new URLSearchParams(window.location.search);
    var page_id = urlSearchParams.get('id');
    var getElementById1 = (id) => {
      const el = document.getElementById(id)
      if (el) {
        return el
      }
      var iframe = document.getElementById("generated-page-iframe");

      // Access the content of the iframe
      var iframeDocument = iframe.contentDocument || iframe.contentWindow.document;

      // Modify the content of the generated-page div within the iframe
      var el2 = iframeDocument.getElementById(id);
      if (el2) {
        return el2
      }
      console.log('not found id1' + id)
      return undefined
    }
    var querySelectorAll1 = (selector) => {

      const els1 = document.querySelectorAll(selector)

      var iframe = document.getElementById("generated-page-iframe");

      // Access the content of the iframe
      var iframeDocument = iframe.contentDocument || iframe.contentWindow.document;


      var els2 = iframeDocument.querySelectorAll(selector);

      console.log('not found all' + selector)
      const res = [...els1, ...els2]
      console.log("r11" + JSON.stringify(Array.from(els1).map(e => e.id)) + selector)
      console.log("r12" + JSON.stringify(Array.from(els2).map(e => e.id)) + selector)
      console.log("r13" + JSON.stringify(Array.from(res).map(e => e.id)) + selector)
      return res
    }
    getElementById1('remove-loading').addEventListener('click', function () {
      getElementById1('loading').remove();
    });

  </script>
  <script>
    const generateBreadCrumb = async (event) => {
      const arr = pathItem.lsi1.split('/')
      const site = arr[0]
      arr.shift()
      arr.pop()
      const active = arr.pop()

      const breadCA = querySelectorAll1('[data-builder-breadcrumb-active]')
      const breadC = querySelectorAll1('[data-builder-breadCrumb]')
      const a = breadC[0].querySelector('[data-builder-breadCrumb-value]')



      const el2 = {
        time: (new Date()).getTime(),
        action: 'setAttribute',
        target_element: a.id + '-tree',
        key: 'href',
        value: 'https://' + site.toLowerCase(),

      }
      await pushAction(el2)

      if (active) {
        const a = breadCA[0].querySelector('[data-builder-breadCrumb-value]')
        const el = {
          time: (new Date()).getTime(),
          action: 'textContent',
          target_element: a.id + '-tree',
          value: active,

        }

        await pushAction(el)
      }

      let last = breadC[0].id + '-tree'
      for (let i = 0; i < arr.length; i++) {
        const id = duplicateId(breadC[0].id).id
        actionObject = {
          time: (new Date()).getTime(),
          action: 'InsertAfter',
          target_element: last,
          inserted_element: { originalId: breadC[0].id + '-tree', id },
        };
        await pushAction(actionObject)
        last = id
        const a = getElementById1(removeLastOccurrence(id, '-tree')).querySelector('[data-builder-breadCrumb-value]')

        let link = 'https://' + site.toLowerCase() + '/'
        const el = {
          time: (new Date()).getTime(),
          action: 'textContent',
          target_element: a.id + '-tree',
          value: arr[i],

        }
        await pushAction(el)
        for (let j = 0; j <= i; j++) {
          link = link + arr[j].toLowerCase() + '/'
        }

        const el2 = {
          time: (new Date()).getTime(),
          action: 'setAttribute',
          target_element: a.id + '-tree',
          key: 'href',
          value: link,

        }
        await pushAction(el2)

      }
      const schema = querySelectorAll1('script[data-transfer-receiver="schema-breadcrumb"]')[0]
      console.log(schema.textContent)
      let json = JSON.parse(schema.textContent)


      json.itemListElement[0].item["@id"] = 'https://' + site
      let link1 = 'https://' + site.toLowerCase() + '/'
      arr.push(active)
      for (let i = 0; i < arr.length; i++) {
        const newEl = deepCopy(json.itemListElement[0])
        link1 = link1 + arr[i] + '/'
        newEl.item["@id"] = link1.toLowerCase()
        newEl.item.name = arr[i].toLowerCase()
        newEl.position = i + 2
        json.itemListElement.push(newEl)
      }
      const el = {
        time: (new Date()).getTime(),
        action: 'innerHtml',
        target_element: schema.id + '-tree',
        insertedCode: JSON.stringify(json, null, 2),

      }
      await pushAction(el)
    }
    const switchSelected = (event) => {
      const activated = event.target.classList.contains('b-selected')
      if (activated) {
        event.target.classList.remove('b-selected')
      }
      else {
        event.target.classList.add('b-selected')
      }
    }
    //toggle menu button scripts
    const toggleGeneratedPage = () => {
      const s = localStorage.getItem('generatedPageToggle')
      if (!s) {

        getElementById1("sku-list").removeAttribute('hidden')
        getElementById1('generated-page').removeAttribute('hidden')
        getElementById1('generated-page-menu').removeAttribute('hidden')
        getElementById1('toggle-generated-page').classList.add('b-selected')
        localStorage.setItem('generatedPageToggle', 'true')
      }
      else {
        getElementById1("sku-list").setAttribute('hidden', '')
        getElementById1('generated-page').setAttribute('hidden', '')
        getElementById1('generated-page-menu').setAttribute('hidden', '')
        getElementById1('toggle-generated-page').classList.remove('b-selected')
        localStorage.removeItem('generatedPageToggle')
      }
    }
    const generateDependeeMenu = (node) => {
      const sku = node.querySelector('#sku-value').textContent
      console.log(sku)
      const item = getElementById1('dependee-menu-item')
      const dependeeMenu = node.querySelector('#dependee-menu')
      const forms = querySelectorAll1('[data-product-attribute-form]');
      const dependees = querySelectorAll1('[data-builder-dependee]');
      const selects = []
      for (let i = 0; i < forms.length; i++) {
        const form = forms[i]
        selects.push(form.querySelector('[data-product-attribute-legend]'))
      }
      const dependees1 = removeDuplicates(Array.from(dependees).map(el => el.getAttribute('data-builder-dependee')))
      dependeeMenu.innerHTML = ''
      const checkbox = getElementById1('checkbox-label')
      for (const dependee of dependees1) {
        console.log('in')
        const cloned = item.cloneNode(true)
        cloned.removeAttribute('hidden')
        cloned.querySelector('[data-type="dependee-value"]').textContent = dependee

        for (const select of selects) {
          const clonedCheckbox = checkbox.cloneNode(true)
          clonedCheckbox.removeAttribute('hidden')
          clonedCheckbox.setAttribute('formId', select.parentNode.id)
          clonedCheckbox.innerHTML = clonedCheckbox.innerHTML.replace('Color', select.textContent)
          cloned.insertBefore(clonedCheckbox, cloned.children[cloned.children.length - 1])
        }
        dependeeMenu.appendChild(cloned)

      }
    }
    var getChecked = (resultList) => {
      const checked1 = []
      for (const el1 of resultList) {
        const selected = el1.form.querySelectorAll('[type="radio"]').forEach(el => {
          if (el.checked) {
            const selectedValue = el.parentNode.querySelector('[data-product-attribute-value]').textContent
            checked1.push(el1.legend + ':' + selectedValue)
          }
        })


      }
      return checked1
    }
    const generateDependees = async (event) => {
      const parentFieldSet = event.target.closest('fieldset')
      const checkboxes = parentFieldSet.querySelectorAll('[data-type="dependant"')
      const skuValue = parentFieldSet.parentNode.parentNode.querySelector('#sku-value').textContent
      const resultList = []
      for (const item of checkboxes) {
        const checkbox = item.firstChild
        if (checkbox.checked) {
          console.log('checkbox ' + checkbox.id)
          const formId = item.getAttribute('formId')
          const form = getElementById1(formId)
          const legendElement = form.querySelector('[data-product-attribute-legend]');
          const legend = legendElement && legendElement.textContent;

          const attributeElements = form.querySelectorAll('[data-product-attribute]');
          const attributes = Array.from(attributeElements).map(element => element.textContent);

          resultList.push({
            form,
            legend: legend,
            items: attributes
          });
        }

      }
      const combinations = generateCombinations(resultList)
      console.log(JSON.stringify(combinations))
      const dependencyName = parentFieldSet.querySelector('[data-type="dependee-value"]').textContent
      let dependeeItems = querySelectorAll1(`[data-builder-dependee="${dependencyName}"]`)
      const allIds = Array.from(dependeeItems).map(e => e.id)
      const ids = []
      const toRemove = []
      for (const id of allIds) {
        if (id.endsWith('-tree')) {
          continue
        }
        const splited = id.split(':')
        if (!ids.find(el => el.startsWith(splited[0] + ':'))) {
          ids.push(id)

        }
        else {
          toRemove.push(id)
        }
      }
      console.log('tr555 ' + JSON.stringify(toRemove))
      console.log('tr555 ' + JSON.stringify(ids))
      for (const id of toRemove) {
        await pushAction({
          time: (new Date()).getTime(),
          action: 'removeTag',
          target_element: id + '-tree',
        })
      }
      for (const id of ids) {
        for (let i = 0; i < combinations.length; i++) {
          let currentId = id + '-tree'

          if (i !== 0) {
            const res = duplicateId(id)
            let actionObject = {
              time: (new Date()).getTime(),
              action: 'InsertBefore',
              target_element: id + '-tree',
              inserted_element: { originalId: id + '-tree', id: res.id },
            };
            await pushAction(actionObject)
            currentId = res.id
          }
          const el = {
            time: (new Date()).getTime(),
            action: 'setAttribute',
            target_element: currentId,
            key: 'data-product-info',
            value: `${skuValue};${combinations[i]}`,

          }
          await pushAction(el)

        }
      }
      //get selected combination
      const checked1 = getChecked(resultList)
      console.log(JSON.stringify(checked1))
      dependeeItems = querySelectorAll1(`[data-builder-dependee="${dependencyName}"]`)
      for (const item of dependeeItems) {
        const attr = item.getAttribute('data-product-info')
        const splited = attr.split(';')
        splited.shift()
        const f = splited.find(el => !checked1.includes(el))
        if (f) {
          item.style.display = 'none'
        }
        else {
          item.style.display = 'block'
        }
      }
      handleDependency()

    }
    const toggleDependencyMenu1 = (event) => {
      const menus = event.target.parentNode.querySelectorAll('#dependee-menu')

      const button = event.target
      if (!button.classList.contains('b-selected')) {
        console.log('setting');

        // Set the item in local storage


        // Remove the 'hidden' attribute to show the menu
        menus.forEach(menu => menu.removeAttribute('hidden'))

        // Add the class 'b-selected' to the toggle button
        button.classList.add('b-selected');
        generateDependeeMenu(event.target.parentNode)
      } else {
        // If the item is set in local storage

        // Remove the item from local storage


        // Remove the class 'b-selected' from the toggle button
        button.classList.remove('b-selected');

        // Set the 'hidden' attribute to hide the menu
        menus.forEach(menu => menu.setAttribute('hidden', ''))
      }
    }
    const toggleSkuAttributeList = (event) => {
      const el = event.target
      const list = el.parentNode.querySelector('#sku-attribute-list')
      if (el.classList.contains('b-selected')) {
        el.classList.remove('b-selected')
        list.setAttribute('hidden', 'true')
      }
      else {
        el.classList.add('b-selected')

        list.removeAttribute('hidden')
      }
    }
    const toggleHead = () => {
      const s = localStorage.getItem('headToggle')
      if (!s) {

        getElementById1('head-1').removeAttribute('hidden')
        getElementById1('head-menu').removeAttribute('hidden', '')
        getElementById1('toggle-head').classList.add('b-selected')
        localStorage.setItem('headToggle', 'true')
      }
      else {
        getElementById1('head-1').setAttribute('hidden', '')
        getElementById1('head-menu').setAttribute('hidden', '')
        getElementById1('toggle-head').classList.remove('b-selected')
        localStorage.removeItem('headToggle')
      }
    }
    const toggleCodeTree = () => {
      const s = localStorage.getItem('codeTreeToggle')
      if (!s) {

        getElementById1('code-tree').removeAttribute('hidden')
        getElementById1('code-tree-menu').removeAttribute('hidden', '')
        getElementById1('toggle-code-tree').classList.add('b-selected')
        localStorage.setItem('codeTreeToggle', 'true')
      }
      else {
        getElementById1('code-tree').setAttribute('hidden', '')
        getElementById1('code-tree-menu').setAttribute('hidden', '')
        getElementById1('toggle-code-tree').classList.remove('b-selected')
        localStorage.removeItem('codeTreeToggle')
      }
    }
    const toggleComponentTree = () => {
      const s = localStorage.getItem('componentTreeToggle')
      if (!s) {

        getElementById1('components-tree').removeAttribute('hidden')
        getElementById1('components-tree-menu').removeAttribute('hidden', '')
        getElementById1('toggle-component-tree').classList.add('b-selected')

        localStorage.setItem('componentTreeToggle', 'true')
      }
      else {
        getElementById1('components-tree').setAttribute('hidden', '')
        getElementById1('components-tree-menu').setAttribute('hidden', '')
        getElementById1('toggle-component-tree').classList.remove('b-selected')
        localStorage.removeItem('componentTreeToggle')
      }
    }
    document.addEventListener('DOMContentLoaded', function () {
      const s1 = localStorage.getItem('codeTreeToggle')
      if (s1) {
        getElementById1('toggle-code-tree').classList.add('b-selected')
      }
      else {
        getElementById1('code-tree-menu').setAttribute('hidden', '')
        getElementById1('code-tree').setAttribute('hidden', '')
      }
      const s2 = localStorage.getItem('componentTreeToggle')
      if (s2) {
        getElementById1('toggle-component-tree').classList.add('b-selected')
      }
      else {
        getElementById1('components-tree').setAttribute('hidden', '')
        getElementById1('components-tree-menu').setAttribute('hidden', '')
      }
      const s3 = localStorage.getItem('headToggle')
      if (s3) {
        getElementById1('toggle-head').classList.add('b-selected')
      }
      else {
        getElementById1('head-menu').setAttribute('hidden', '')
        getElementById1('head-1').setAttribute('hidden', '')
      }
      const s4 = localStorage.getItem('generatedPageToggle')
      if (s4) {
        getElementById1('toggle-generated-page').classList.add('b-selected')
      }
      else {
        getElementById1('generated-page-menu').setAttribute('hidden', '')
        getElementById1('generated-page').setAttribute('hidden', '')
      }


    })

  </script>
  <script>

    var pathItem
    var dependencyItem
    var skuCreated
    var updatePathItem = () =>
      fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(pathItem),
      });

    const switchOptionalScript = (updateDb) => {
      const el = getElementById1('optional-script')
      if (!updateDb) {
        el.classList.add('b-selected');
        return
      }
      if (pathItem.optionalScript) {
        pathItem.optionalScript = false
        el.classList.remove('b-selected');
      }
      else {
        pathItem.optionalScript = true
        el.classList.add('b-selected');
      }
      updatePathItem()


    }
    const switchLinkBP = (updateDb) => {
      const el = getElementById1('link-by-path')
      if (!updateDb) {
        el.classList.add('b-selected');
        return
      }
      if (pathItem.LinkBP) {
        pathItem.LinkBP = false
        el.classList.remove('b-selected');
      }
      else {
        pathItem.LinkBP = true
        el.classList.add('b-selected');
      }
      updatePathItem()
    }
    const switchTest = (updateDb) => {
      const el = getElementById1('test-component')
      if (!updateDb) {
        el.classList.add('b-selected');
        return
      }
      if (pathItem.testPage) {
        pathItem.testPage = false
        el.classList.remove('b-selected');

      }
      else {
        pathItem.testPage = true
        el.classList.add('b-selected');
      }
      updatePathItem()
    }
    //not used
    const addComponent1 = (id) => {
      //getElementById1('file-list-attach-component-options;').remove()
      const actionObject = {
        time: (new Date()).getTime(),
        action: 'Add_Component',
        target_element: page_id + '-tree',
        inserted_component: { componentId: id, id: generateUUID() },
      };
      pushAction(actionObject);
    }
    var loadUsingPath2 = (path1, filePathList, optionList) => {
      return fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?ownerUUID=path&gsi1lsi1=true&lsi1=' + path1)
        .then(response => response.json())
        .then(data => {
          // Replace existing file paths with dynamic content

          filePathList.innerHTML = '';
          let i = 0
          let folders = []
          const elements = []
          console.log(JSON.stringify(data))
          const items = data.items.filter(i => i.lsi1).map(item1 => { return { ...item1, name: item1.lsi1.replace(path1, '').split(';')[0] } })
          console.log(JSON.stringify(items))
          for (const item of items) {
            const splited = item.name.split(';')[0].split('/')
            if (splited.length > 1) {
              folders.push(splited[0])
            }
            else {
              elements.push({ name: splited[0], ...item })
            }
          }
          folders = removeDuplicates(folders)
          console.log(JSON.stringify(folders))
          console.log(JSON.stringify(elements))

          folders.forEach(item => {


            if (i < 1000) {
              i++
              // Clone the fieldset
              var clonedItem = getElementById1('item').cloneNode(true);

              // Set unique ID for the cloned item
              clonedItem.id = item;

              // Set file path and emoji
              const file_path = clonedItem.querySelector('[data-value="file-path"]')
              file_path.textContent = item;
              clonedItem.onclick = setPath
              let icon = '📂';

              clonedItem.querySelector('[data-value="file-emoji"]').textContent = icon;

              // Set file ID
              clonedItem.querySelector('[data-value="file-id"]').textContent = item;

              // Set up onclick for file-open button
              function setPath() {
                path1 = path1 + item + '/'
                loadUsingPath2(path1, filePathList, optionList)
              };

              // Append the cloned item to the filePathList
              filePathList.appendChild(clonedItem);
            }

          });
          elements && elements.forEach(item => {


            if (i < 1000) {
              i++
              // Clone the fieldset
              var clonedItem = getElementById1('item').cloneNode(true);

              // Set unique ID for the cloned item
              clonedItem.id = item.id;

              // Set file path and emoji
              const item_path = clonedItem.querySelector('[data-value="file-path"]')
              item_path.textContent = item.name;
              clonedItem.onclick = function (event) {
                event.stopPropagation()
                fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2/' + item.id + ':' + item.sk)
                  .then(response => response.json())
                  .then(data => {
                    if (data.LinkBP || optionList.querySelector('#file-list-link-by-path').classList.contains('b-selected')) {
                      const p = data.lsi1.split('/')
                      p.shift()
                      addComponent1("*/" + p.join('/'))
                    }
                    else if (optionList.querySelector('#file-list-link-by-name').classList.contains('b-selected')) {
                      const p = data.lsi1.split('/')

                      addComponent1("#" + p.pop())
                    }
                    else {
                      addComponent1(item.id)
                    }

                    filePathList.remove()
                  })

              };
              let icon = '🧩';
              if (item.lsi1.startsWith('css')) {
                icon = '🎨';
              } else if (item.lsi1.startsWith('javascript')) {
                icon = '💻';
              }
              clonedItem.querySelector('[data-value="file-emoji"]').textContent = icon;

              // Set file ID
              clonedItem.querySelector('[data-value="file-id"]').textContent = item.id;

              clonedItem.querySelector('[data-action="remove-file-confirmation"]').onclick = function (event) {
                event.stopPropagation()
                remove(event, item.id);
              };
              // Append the cloned item to the filePathList
              filePathList.appendChild(clonedItem);
            }

          });



        })
        .catch(error => console.error('Error:', error));
    }
    var loadFileList2 = (filePathList, optionList) => {
      // Fetch GET request

      fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?ownerUUID=path&gsi1lsi1=true')
        .then(response => response.json())
        .then(data => {
          // Replace existing file paths with dynamic content
          filePathList.innerHTML = '';
          let i = 0;
          let folders = []
          const elements = []
          console.log(JSON.stringify(data))
          const items = data.items.filter(i => i.lsi1).map(item1 => { return { ...item1, name: item1.lsi1.split(';')[0] } })
          console.log('ites' + JSON.stringify(items))
          for (const item of items) {
            const splited = item.name.split(';')[0].split('/')
            if (splited.length > 1) {
              folders.push(splited[0])
            }
            else {
              elements.push({ name: splited[0], ...item })
            }
          }
          folders = removeDuplicates(folders)
          console.log(JSON.stringify(elements))
          folders.forEach(item => {


            if (i < 1000) {
              i++
              // Clone the fieldset
              var clonedItem = getElementById1('item').cloneNode(true);

              // Set unique ID for the cloned item
              clonedItem.id = item;

              // Set file path and emoji
              const file_path = clonedItem.querySelector('[data-value="file-path"]')
              file_path.textContent = item;
              clonedItem.onclick = setPath
              let icon = '📂';

              clonedItem.querySelector('[data-value="file-emoji"]').textContent = icon;

              // Set file ID
              clonedItem.querySelector('[data-value="file-id"]').textContent = item;

              // Set up onclick for file-open button
              function setPath() {
                const path1 = item + '/'


                loadUsingPath2(path1, filePathList, optionList)
              };

              // Append the cloned item to the filePathList
              filePathList.appendChild(clonedItem);
            }

          });
          elements && elements.forEach(item => {


            if (i < 1000) {
              i++
              // Clone the fieldset
              var clonedItem = getElementById1('item').cloneNode(true);

              // Set unique ID for the cloned item
              clonedItem.id = item.id;

              // Set file path and emoji
              const item_path = clonedItem.querySelector('[data-value="file-path"]')
              item_path.textContent = item.name;
              clonedItem.onclick = function (event) {
                event.stopPropagation()
                fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2/' + item.id + ':' + item.sk)
                  .then(response => response.json())
                  .then(data => {

                    if (data.LinkBP || optionList.querySelector('#file-list-link-by-path').classList.contains('b-selected')) {
                      const p = data.lsi1.split('/')
                      p.shift()
                      addComponent1("*/" + p.join('/'))
                    }
                    else if (optionList.querySelector('#file-list-link-by-name').classList.contains('b-selected')) {
                      const p = data.lsi1.split('/')

                      addComponent1("#" + p.pop())
                    }
                    else {
                      addComponent1(item.id)
                    }

                    filePathList.remove()
                  })

              };
              let icon = '🧩';
              if (item.lsi1.startsWith('css')) {
                icon = '🎨';
              } else if (item.lsi1.startsWith('javascript')) {
                icon = '💻';
              }
              clonedItem.querySelector('[data-value="file-emoji"]').textContent = icon;

              // Set file ID
              clonedItem.querySelector('[data-value="file-id"]').textContent = item.id;

              // Set up onclick for file-open button

              clonedItem.querySelector('[data-action="remove-file-confirmation"]').onclick = function (event) {
                event.stopPropagation()
                remove(event, item.id);
              };
              // Append the cloned item to the filePathList
              filePathList.appendChild(clonedItem);
            }

          });



          // Show the cloned fieldsets
          querySelectorAll1('#filePathList fieldset').forEach(fieldset => {
            fieldset.id !== 'cancelation' && fieldset.removeAttribute('hidden');
          });




        })
        .catch(error => console.error('Error:', error));

    }
    //end not used
    var addComponent = (e) => {

      let selected = []
      let path1 = ''
      var addSelected = (itemId, path) => {
        const clonedFieldset2 = getElementById1('file-list-attach-component-options;')
        if (Array.from(clonedFieldset2.children).find(el => el.id === itemId)) {
          return
        }
        var clonedItem = getElementById1('item').cloneNode(true);
        selected.push(itemId)
        clonedItem.id = itemId;
        const file_path = clonedItem.querySelector('[data-value="file-path"]')
        file_path.textContent = path;
        clonedItem.querySelector('#Pushpin').removeAttribute('hidden')
        clonedItem.onclick = (e) => { e.target.closest('li').remove(); selected.filter(el => el !== itemId) }
        clonedFieldset2.appendChild(clonedItem)
        console.log(JSON.stringify(selected))

      }




      var loadUsingPath1 = (path) => {
        return fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?ownerUUID=path&gsi1lsi1=true&lsi1=' + path1)
          .then(response => response.json())
          .then(data => {
            // Replace existing file paths with dynamic content
            var filePathList = getElementById1('filePathList;');
            filePathList.innerHTML = '';
            lvls = []
            let i = 0
            let folders = []
            const elements = []
            console.log(JSON.stringify(data))
            const items = data.items.filter(i => i.lsi1).map(item1 => { return { ...item1, name: item1.lsi1.replace(path1, '').split(';')[0] } })
            console.log(JSON.stringify(items))
            for (const item of items) {
              const splited = item.name.split(';')[0].split('/')
              if (splited.length > 1) {
                folders.push(splited[0])
              }
              else {
                elements.push({ name: splited[0], ...item })
              }
            }
            folders = removeDuplicates(folders)
            console.log(JSON.stringify(folders))
            console.log(JSON.stringify(elements))

            folders.forEach(item => {


              if (i < 1000) {
                i++
                // Clone the fieldset
                var clonedItem = getElementById1('item').cloneNode(true);

                // Set unique ID for the cloned item
                clonedItem.id = item;

                // Set file path and emoji
                const file_path = clonedItem.querySelector('[data-value="file-path"]')
                file_path.textContent = item;
                clonedItem.onclick = setPath
                let icon = '📂';

                clonedItem.querySelector('[data-value="file-emoji"]').textContent = icon;

                // Set file ID
                clonedItem.querySelector('[data-value="file-id"]').textContent = item;

                // Set up onclick for file-open button
                function setPath() {
                  path1 = path1 + item + '/'
                  loadUsingPath1(path1)
                };

                // Append the cloned item to the filePathList
                filePathList.appendChild(clonedItem);
              }

            });
            elements && elements.forEach(item => {


              if (i < 1000) {
                i++
                // Clone the fieldset
                var clonedItem = getElementById1('item').cloneNode(true);

                // Set unique ID for the cloned item
                clonedItem.id = item.id;

                // Set file path and emoji
                const item_path = clonedItem.querySelector('[data-value="file-path"]')
                item_path.textContent = item.name;
                clonedItem.onclick = function (event) {

                  addSelected(item.id, item.lsi1);
                };
                let icon = '🧩';
                if (item.lsi1.startsWith('css')) {
                  icon = '🎨';
                } else if (item.lsi1.startsWith('javascript')) {
                  icon = '💻';
                }
                clonedItem.querySelector('[data-value="file-emoji"]').textContent = icon;

                // Set file ID
                clonedItem.querySelector('[data-value="file-id"]').textContent = item.id;

                clonedItem.querySelector('[data-action="remove-file-confirmation"]').onclick = function (event) {
                  event.stopPropagation()
                  remove(event, item.id);
                };
                // Append the cloned item to the filePathList
                filePathList.appendChild(clonedItem);
              }

            });



          })
          .catch(error => console.error('Error:', error));
      }
      var loadFileList1 = () => {
        // Fetch GET request

        fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?ownerUUID=path&gsi1lsi1=true')
          .then(response => response.json())
          .then(data => {
            // Replace existing file paths with dynamic content
            var filePathList = getElementById1('filePathList;');
            filePathList.innerHTML = '';
            let i = 0;
            let folders = []
            const elements = []
            console.log(JSON.stringify(data))
            const items = data.items.filter(i => i.lsi1).map(item1 => { return { ...item1, name: item1.lsi1.replace(path1, '').split(';')[0] } })
            console.log('ites' + JSON.stringify(items))
            for (const item of items) {
              const splited = item.name.split(';')[0].split('/')
              if (splited.length > 1) {
                folders.push(splited[0])
              }
              else {
                elements.push({ name: splited[0], ...item })
              }
            }
            folders = removeDuplicates(folders)
            console.log(JSON.stringify(elements))
            folders.forEach(item => {


              if (i < 1000) {
                i++
                // Clone the fieldset
                var clonedItem = getElementById1('item').cloneNode(true);

                // Set unique ID for the cloned item
                clonedItem.id = item;

                // Set file path and emoji
                const file_path = clonedItem.querySelector('[data-value="file-path"]')
                file_path.textContent = item;
                clonedItem.onclick = setPath
                let icon = '📂';

                clonedItem.querySelector('[data-value="file-emoji"]').textContent = icon;

                // Set file ID
                clonedItem.querySelector('[data-value="file-id"]').textContent = item;

                // Set up onclick for file-open button
                function setPath() {
                  path1 = item + '/'


                  loadUsingPath1(path1)
                };

                // Append the cloned item to the filePathList
                filePathList.appendChild(clonedItem);
              }

            });
            elements && elements.forEach(item => {


              if (i < 1000) {
                i++
                // Clone the fieldset
                var clonedItem = getElementById1('item').cloneNode(true);

                // Set unique ID for the cloned item
                clonedItem.id = item.id;

                // Set file path and emoji
                const item_path = clonedItem.querySelector('[data-value="file-path"]')
                item_path.textContent = item.name;
                clonedItem.onclick = function (event) {
                  event.stopPropagation()
                  addSelected(item.id, item.lsi1);
                };
                let icon = '🧩';
                if (item.lsi1.startsWith('css')) {
                  icon = '🎨';
                } else if (item.lsi1.startsWith('javascript')) {
                  icon = '💻';
                }
                clonedItem.querySelector('[data-value="file-emoji"]').textContent = icon;

                // Set file ID
                clonedItem.querySelector('[data-value="file-id"]').textContent = item.id;

                // Set up onclick for file-open button

                clonedItem.querySelector('[data-action="remove-file-confirmation"]').onclick = function (event) {
                  event.stopPropagation()
                  remove(event, item.id);
                };
                // Append the cloned item to the filePathList
                filePathList.appendChild(clonedItem);
              }

            });



            // Show the cloned fieldsets
            querySelectorAll1('#filePathList fieldset').forEach(fieldset => {
              fieldset.id !== 'cancelation' && fieldset.removeAttribute('hidden');
            });



            // Update select options

          })
          .catch(error => console.error('Error:', error));

      }

      const fieldset = getElementById1('filePathList');
      const fieldset2 = getElementById1('selectedFilePathList');
      if (!e.target.parentNode.nextElementSibling || !e.target.parentNode.nextElementSibling.id.startsWith('filePathList')) {
        const clonedFieldset = fieldset.cloneNode(true);
        const clonedFieldset2 = fieldset2.cloneNode(true);
        const clonedFieldset3 = getElementById1('file-list-attach-component-options').cloneNode(true);
        clonedFieldset3.removeAttribute('hidden')
        clonedFieldset3.id = 'file-list-attach-component-options;'

        clonedFieldset.id = clonedFieldset.id + ';';
        clonedFieldset.setAttribute('action', 'Add_Component')
        clonedFieldset3.querySelector('[data-action="moveBack"]').onclick = (e) => {
          const splited = path1.split('/')
          if (path1 === '') {
            return
          }
          else if (splited.length === 2) {
            path1 === ""
            loadFileList1()

          }
          else {
            splited.pop()
            splited.pop()
            path1 = splited.join('/') + '/'
            loadUsingPath1(path1)

          }
        }
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset);
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset3);

        loadFileList1()

      }

    }
    var addTreeElement = (e) => {
      const fieldset = getElementById1('tag-table');
      console.log('clicked')
      if (!e.target.parentNode.nextElementSibling || !e.target.parentNode.nextElementSibling.id.startsWith('tag-table')) {
        const clonedFieldset = fieldset.cloneNode(true);

        const clonedRows = clonedFieldset.getElementsByTagName('tbody')[0].getElementsByTagName('tr');
        for (let i = 0; i < clonedRows.length; i++) {
          const index = i; // Capture the current value of 'i' in a closure
          clonedRows[i].onclick = function (event) {
            chooseTag(index, event);
          };
        }
        clonedFieldset.id = clonedFieldset.id + ';' + page_id + '-tree';
        clonedFieldset.setAttribute('action', 'Insert_First')
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset);
      }

    }
  </script>
  <script>
    var approveAddComponent = async (e) => {
      const m1 = e.target.parentNode.querySelectorAll('[data-element="file-path"]')

      
      const ids = Array.from(m1).map(e => e.id)
      const optionList = getElementById1('file-list-attach-component-options;')
      for (const id of ids) {
        const data = await fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2/' + id + ':path')
          .then(response => response.json())

        if (data.LinkBP || optionList.querySelector('#file-list-link-by-path').classList.contains('b-selected')) {
          const p = data.lsi1.split('/')
          p.shift()
          addComponent1("*/" + p.join('/'))
        }
        else if (optionList.querySelector('#file-list-link-by-name').classList.contains('b-selected')) {
          const p = data.lsi1.split('/')

          addComponent1("#" + p.pop())
        }
        else {
          addComponent1(id)
        }
      }

      getElementById1('file-list-attach-component-options;').remove()
      getElementById1('filePathList;').remove()
    }
    var approveReplace = async (e) => {
      const m1 = Array.from(e.target.parentNode.children).filter(i => i.id)
      const parentId = e.target.parentNode.id.replace('file-path-list;', '')
      const parentEl = getElementById1(parentId)
      const replacedString = parentEl.getAttribute('replaced')
      const replaced = replacedString ? JSON.parse(replacedString) : []
      const el = {
        time: (new Date()).getTime(),
        action: 'Replace_Component',
        target_element: [parentId.replace('selectedFilePathList;', ''), ...m1.map(el => {
          const element = getElementById1(el.id);
          return {

            componentId: el.id, id: el.newId || generateUUID(), path: element.querySelector('[data-value="file-path"]').textContent, already: element.getAttribute('alreadyReplaced')
          }
        })],
      };

      await pushAction(el)
      location.reload()
    }
    //file list scripts
    var replaceComponent = (e, flag) => {
      let selected = []
      let path1 = ''
      var addSelected = (id, itemId, path) => {
        const clonedFieldset2 = getElementById1('selectedFilePathList;' + id)
        if (Array.from(clonedFieldset2.children).find(el => el.id === itemId)) {
          return
        }
        var clonedItem = getElementById1('item').cloneNode(true);
        selected.push(itemId)
        clonedItem.id = itemId;
        const file_path = clonedItem.querySelector('[data-value="file-path"]')
        file_path.textContent = path;
        clonedItem.querySelector('#Pushpin').removeAttribute('hidden')
        clonedItem.onclick = (e) => { e.target.closest('li').remove(); selected.filter(el => el !== itemId) }
        clonedFieldset2.appendChild(clonedItem)
        console.log(JSON.stringify(selected))

      }




      var loadUsingPath1 = (id, path) => {
        return fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?ownerUUID=path&gsi1lsi1=true&lsi1=' + path1)
          .then(response => response.json())
          .then(data => {
            // Replace existing file paths with dynamic content
            var filePathList = getElementById1('filePathList;' + id);
            filePathList.innerHTML = '';
            lvls = []
            let i = 0
            let folders = []
            const elements = []
            console.log(JSON.stringify(data))
            const items = data.items.filter(i => i.lsi1).map(item1 => { return { ...item1, name: item1.lsi1.replace(path1, '').split(';')[0] } })
            console.log(JSON.stringify(items))
            for (const item of items) {
              const splited = item.name.split(';')[0].split('/')
              if (splited.length > 1) {
                folders.push(splited[0])
              }
              else {
                elements.push({ name: splited[0], ...item })
              }
            }
            folders = removeDuplicates(folders)
            console.log(JSON.stringify(folders))
            console.log(JSON.stringify(elements))

            folders.forEach(item => {


              if (i < 1000) {
                i++
                // Clone the fieldset
                var clonedItem = getElementById1('item').cloneNode(true);

                // Set unique ID for the cloned item
                clonedItem.id = item;

                // Set file path and emoji
                const file_path = clonedItem.querySelector('[data-value="file-path"]')
                file_path.textContent = item;
                clonedItem.onclick = setPath
                let icon = '📂';

                clonedItem.querySelector('[data-value="file-emoji"]').textContent = icon;

                // Set file ID
                clonedItem.querySelector('[data-value="file-id"]').textContent = item;

                // Set up onclick for file-open button
                function setPath() {
                  path1 = path1 + item + '/'
                  loadUsingPath1(id, path1)
                };

                // Append the cloned item to the filePathList
                filePathList.appendChild(clonedItem);
              }

            });
            elements && elements.forEach(item => {


              if (i < 1000) {
                i++
                // Clone the fieldset
                var clonedItem = getElementById1('item').cloneNode(true);

                // Set unique ID for the cloned item
                clonedItem.id = item.id;

                // Set file path and emoji
                const item_path = clonedItem.querySelector('[data-value="file-path"]')
                item_path.textContent = item.name;
                clonedItem.onclick = function (event) {

                  addSelected(id, item.id, item.lsi1);
                };
                let icon = '🧩';
                if (item.lsi1.startsWith('css')) {
                  icon = '🎨';
                } else if (item.lsi1.startsWith('javascript')) {
                  icon = '💻';
                }
                clonedItem.querySelector('[data-value="file-emoji"]').textContent = icon;

                // Set file ID
                clonedItem.querySelector('[data-value="file-id"]').textContent = item.id;

                clonedItem.querySelector('[data-action="remove-file-confirmation"]').onclick = function (event) {
                  event.stopPropagation()
                  remove(event, item.id);
                };
                // Append the cloned item to the filePathList
                filePathList.appendChild(clonedItem);
              }

            });



          })
          .catch(error => console.error('Error:', error));
      }
      var loadFileList1 = (id) => {
        // Fetch GET request

        fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?ownerUUID=path&gsi1lsi1=true')
          .then(response => response.json())
          .then(data => {
            // Replace existing file paths with dynamic content
            var filePathList = getElementById1('filePathList;' + id);
            filePathList.innerHTML = '';
            let i = 0;
            let folders = []
            const elements = []
            console.log(JSON.stringify(data))
            const items = data.items.filter(i => i.lsi1).map(item1 => { return { ...item1, name: item1.lsi1.replace(path1, '').split(';')[0] } })
            console.log('ites' + JSON.stringify(items))
            for (const item of items) {
              const splited = item.name.split(';')[0].split('/')
              if (splited.length > 1) {
                folders.push(splited[0])
              }
              else {
                elements.push({ name: splited[0], ...item })
              }
            }
            folders = removeDuplicates(folders)
            console.log(JSON.stringify(elements))
            folders.forEach(item => {


              if (i < 1000) {
                i++
                // Clone the fieldset
                var clonedItem = getElementById1('item').cloneNode(true);

                // Set unique ID for the cloned item
                clonedItem.id = item;

                // Set file path and emoji
                const file_path = clonedItem.querySelector('[data-value="file-path"]')
                file_path.textContent = item;
                clonedItem.onclick = setPath
                let icon = '📂';

                clonedItem.querySelector('[data-value="file-emoji"]').textContent = icon;

                // Set file ID
                clonedItem.querySelector('[data-value="file-id"]').textContent = item;

                // Set up onclick for file-open button
                function setPath() {
                  path1 = item + '/'


                  loadUsingPath1(id, path1)
                };

                // Append the cloned item to the filePathList
                filePathList.appendChild(clonedItem);
              }

            });
            elements && elements.forEach(item => {


              if (i < 1000) {
                i++
                // Clone the fieldset
                var clonedItem = getElementById1('item').cloneNode(true);

                // Set unique ID for the cloned item
                clonedItem.id = item.id;

                // Set file path and emoji
                const item_path = clonedItem.querySelector('[data-value="file-path"]')
                item_path.textContent = item.name;
                clonedItem.onclick = function (event) {
                  event.stopPropagation()
                  addSelected(id, item.id, item.lsi1);
                };
                let icon = '🧩';
                if (item.lsi1.startsWith('css')) {
                  icon = '🎨';
                } else if (item.lsi1.startsWith('javascript')) {
                  icon = '💻';
                }
                clonedItem.querySelector('[data-value="file-emoji"]').textContent = icon;

                // Set file ID
                clonedItem.querySelector('[data-value="file-id"]').textContent = item.id;

                // Set up onclick for file-open button

                clonedItem.querySelector('[data-action="remove-file-confirmation"]').onclick = function (event) {
                  event.stopPropagation()
                  remove(event, item.id);
                };
                // Append the cloned item to the filePathList
                filePathList.appendChild(clonedItem);
              }

            });



            // Show the cloned fieldsets
            querySelectorAll1('#filePathList fieldset').forEach(fieldset => {
              fieldset.id !== 'cancelation' && fieldset.removeAttribute('hidden');
            });



            // Update select options

          })
          .catch(error => console.error('Error:', error));

      }
      const splited = e.target.parentNode.id.split(';')
      const path = e.target.parentNode.getAttribute('path')
      const replacedString = e.target.parentNode.getAttribute('replaced')
      const replaced = replacedString ? JSON.parse(replacedString) : undefined
      const [toRemove, ...rest] = splited
      const parentId = splited.length === 1 ? e.target.parentNode.id : rest.join(';')
      const fieldset = getElementById1('filePathList');
      const fieldset2 = getElementById1('selectedFilePathList');
      if (!e.target.parentNode.nextElementSibling || !e.target.parentNode.nextElementSibling.id.startsWith('filePathList')) {
        const clonedFieldset = fieldset.cloneNode(true);
        const clonedFieldset2 = fieldset2.cloneNode(true);
        clonedFieldset2.id = clonedFieldset2.id + ';' + parentId;
        clonedFieldset.id = clonedFieldset.id + ';' + parentId;
        clonedFieldset.setAttribute('action', 'Replace')
        clonedFieldset2.setAttribute('action', 'Replace')
        clonedFieldset2.querySelector('[data-action="moveBack"]').onclick = (e) => {
          const splited = path1.split('/')
          if (path1 === '') {
            return
          }
          else if (splited.length === 2) {
            path1 === ""
            loadFileList1(parentId)

          }
          else {
            splited.pop()
            splited.pop()
            path1 = splited.join('/') + '/'
            loadUsingPath1(parentId, path1)

          }
        }
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset);
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset2);
        !flag && e.target.parentNode.remove()
        if (!replaced) {
          var clonedItem = getElementById1('item').cloneNode(true);
          clonedItem.setAttribute('alreadyReplaced', true)
          clonedItem.id = parentId;
          selected.push(parentId)
          const file_path = clonedItem.querySelector('[data-value="file-path"]')
          file_path.textContent = path;
          clonedItem.querySelector('#Pushpin').removeAttribute('hidden')
          clonedFieldset2.appendChild(clonedItem)
          clonedItem.onclick = (e) => { e.target.closest('li').remove(); selected.filter(el => el !== parentId) }
        }
        else {
          for (const el of replaced) {
            var clonedItem = getElementById1('item').cloneNode(true);
            clonedItem.setAttribute('alreadyReplaced', true)
            clonedItem.id = el.componentId;
            clonedItem.setAttribute('newId', el.id)
            selected.push(el.id)
            const file_path = clonedItem.querySelector('[data-value="file-path"]')
            file_path.textContent = el.path;
            clonedItem.querySelector('#Pushpin').removeAttribute('hidden')
            clonedFieldset2.appendChild(clonedItem)
            clonedItem.onclick = (e) => { e.target.closest('li').remove(); selected.filter(el => el !== el.id) }
          }
        }

        loadFileList1(parentId)
      }
    }

  </script>
  <script>
    let path = ''
    let lvls = []
    var removeLastOccurrence = (inputString, substringToRemove) => {
      const lastIndexOfSubstring = inputString.lastIndexOf(substringToRemove);

      if (lastIndexOfSubstring !== -1) {
        // If the substring is found, remove it and return the modified string
        const res = inputString.slice(0, lastIndexOfSubstring) + inputString.slice(lastIndexOfSubstring + substringToRemove.length);
        console.log('OUTPUT ' + res)
        return res
      } else {
        // If the substring is not found, return the original string
        return inputString;
      }
    }
    async function removeAttributeFromCopies(event) {
      const saveButton = event.target;
      const tr = saveButton.closest('#code-tree-tag-attributes-list-item');

      if (!tr) {
        console.error('Could not find parent tr element');
        return;
      }

      const keyElement = tr.querySelector('#code-tree-tag-attribute-key');
      const key = keyElement.textContent.replace('🔑', '');

      const parentMenu = event.target.closest('.menu-1');

      if (!parentMenu) {
        console.error('Could not find parent menu element');
        return;
      }

      const { id } = parentMenu;
      const action = 'removeAttributeFromCopies';
      console.log('Action: ' + action);

      const splited = id.split(';');
      const [toRemove, ...rest] = splited;

      const el = {
        time: (new Date()).getTime(),
        action,
        target_element: rest.join(';'),
        key,
      };

      tr.remove();
      console.log(JSON.stringify(el));
      await pushAction(el);

      console.log(JSON.stringify(actionLog));
    }
    async function removeAttribute1(event) {
      const saveButton = event.target;
      const tr = saveButton.closest('#code-tree-tag-attributes-list-item');

      if (!tr) {
        console.error('Could not find parent tr element');
        return;
      }

      const keyElement = tr.querySelector('#code-tree-tag-attribute-key');
      const key = keyElement.textContent.replace('🔑', '');

      const parentMenu = event.target.closest('.menu-1');

      if (!parentMenu) {
        console.error('Could not find parent menu element');
        return;
      }

      const { id } = parentMenu;
      const action = 'removeAttribute';
      console.log('Action: ' + action);

      const splited = id.split(';');
      const [toRemove, ...rest] = splited;

      const el = {
        time: (new Date()).getTime(),
        action,
        target_element: rest.join(';'),
        key,
      };

      tr.remove();
      console.log(JSON.stringify(el));
      await pushAction(el);

      console.log(JSON.stringify(actionLog));
    }
    let visualOn = false
    function duplicateId(originalId,) {
      const splited = originalId.split(';');
      const lastId = splited[splited.length - 1]
      let newLastUUID
      const splited2 = lastId.split(':')
      const copyId = generateUUID()
      newLastUUID = splited2[0] + ':' + copyId
      splited.pop()
      return { id: [...splited, newLastUUID].join(';') + '-tree', copyId }

    }

    function transformToVisual(event) {

      localStorage.setItem('visualOn', 'true')
      if (visualOn) {
        localStorage.removeItem('visualOn')
        location.reload()
        return;
      }

      event.target.classList.add('b-selected');
      visualOn = true
      console.log('transforming');
      var generatedPage = getElementById1("generated-page");

      // Process each child element
      var children = generatedPage.children;
      for (var i = 0; i < children.length; i++) {
        processElement(children[i]);
      }

      // Define the function to be removed
      function handleMouseOver(event) {
        if (event.target.hasAttribute('data-visual-element')) {
          event.target.style.backgroundColor = 'pink';
        }
      }

      // Add the event listener
      var iframe = getElementById1("generated-page-iframe");
      var iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
      iframeDocument.addEventListener('mouseover', handleMouseOver);


      iframeDocument.addEventListener('mouseout', function (event) {
        if (event.target.hasAttribute('data-visual-element')) {
          event.target.style.backgroundColor = '';
        }
      });


      function clickRemoveButton(clickEvent) {
        // Check if the clicked element or its ancestor is a button
        const isButton = clickEvent.target.closest('.receive-target');

        // Check if the clicked element or its ancestor has the class 'menu-option'
        const isMenuOption = clickEvent.target.closest('.menu-option');

        if (!isButton && !isMenuOption) {
          // If the clicked element is not a button and not inside an element with class 'menu-option', remove the buttons
          removeButtons();
        }
      }
      const showEditHrefMenu = (target) => {
        const editHref = getElementById1('update-href-menu')
        const cloned = editHref.cloneNode(true)
        cloned.id = cloned.id + ';' + target.id
        cloned.querySelector('#editHrefButton').onclick = async (e) => {
          const inputValue = e.target.parentNode.querySelector('#editHrefInput').value
          const el = {
            time: (new Date()).getTime(),
            action: 'setAttribute',
            target_element: target.id + '-tree',
            key: 'href',
            value: inputValue,

          }
          await pushAction(el)
          e.target.parentNode.remove()

        }
        target.appendChild(cloned)

      }
      function handleContextMenu(e) {
        if (e.target.hasAttribute('data-visual-element')) {
          e.preventDefault(); // Prevent the default context menu from opening
          console.log('in11');
          const menu = getElementById1('right-click-menu'); // Use # for ID selector
          menu.innerHTML = '';
          let siblingsWithDuplicate
          let fieldsetSiblings
          let parentWithAppendChild
          let siblingWithInsertBefore
          console.log('tag ' + e.target.tagName)
          const redirectToImgPage = (imgId, src) => {
            const urlSearchParams = new URLSearchParams(window.location.search);
            const id = urlSearchParams.get('id');
            console.log('in1')
            window.location.href = `gallery.html?id=${id}&imgId=${imgId}&src=${src}`;
          }
          if (e.target.tagName.toLowerCase() === 'img') {
            addMenuEntry(menu, `🖼️ Edit image`, () => {
              redirectToImgPage(e.target.id, e.target.getAttribute('src'))
            });
          }
          if (e.target.hasAttribute('data-visual-href')) {
            addMenuEntry(menu, `🔗 Edit href`, () => {
              showEditHrefMenu(e.target)
            });
          }
          if (
            e.target.parentElement.id === e.target.id + '-fieldset') {
            // Check for data-visual-duplicate siblings
            console.log('case1')
            siblingsWithDuplicate = Array.from(e.target.parentElement.parentElement.children).filter(
              sibling => sibling.hasAttribute('data-visual-dublicate')
            );

            // Check for fieldset siblings containing data-visual-duplicate elements
            fieldsetSiblings = Array.from(e.target.parentElement.parentElement.children).filter(
              sibling => sibling.tagName === 'FIELDSET' &&
                Array.from(sibling.querySelectorAll('[data-visual-dublicate]')).length > 0
            );
            // Check if parent has data-visual-appendChild
            parentWithAppendChild = e.target.parentElement.parentElement.hasAttribute('data-visual-appendchild') && e.target.parentElement.parentElement;

            // Check sibling for data-visual-insertBefore
            siblingWithInsertBefore = e.target.parentElement.parentElement && Array.from(e.target.parentElement.parentElement.children).filter(
              child => child.hasAttribute('data-visual-insertbefore') || (child.id.endsWith('-fieldset') && child.children[1].hasAttribute('data-visual-insertbefore'))
            );
          }
          else {
            console.log('case2')
            // Check for data-visual-duplicate siblings
            let ids = []
            siblingsWithDuplicate = Array.from(e.target.parentElement.children).filter(

              sibling => {

                if (sibling.hasAttribute('data-visual-dublicate')) {

                  const id = sibling.id
                  const splited = id.split(';')
                  const last = splited[splited.length - 1]
                  const splited2 = last.replace('-tree', '').split(':')
                  const lastId = splited2[0]
                  splited.pop()
                  const toCheck = [...splited, lastId].join(';')
                  if (ids.includes(toCheck)) {
                    return false
                  }
                  ids.push(toCheck)
                  return true
                }
                return false
              }
            );

            // Check for fieldset siblings containing data-visual-duplicate elements
            ids = []
            fieldsetSiblings = Array.from(e.target.parentElement.children).filter(
              sibling => {
                if (sibling.tagName === 'FIELDSET' &&
                  Array.from(sibling.querySelectorAll('[data-visual-dublicate]')).length > 0) {
                  const id = sibling.id
                  const splited = id.split(';')
                  const last = splited[splited.length - 1]
                  const splited2 = last.replace('-tree', '').split(':')
                  const lastId = splited2[0]
                  splited.pop()
                  const toCheck = [...splited, lastId].join(';')
                  if (ids.includes(toCheck)) {
                    return false
                  }
                  ids.push(toCheck)
                  return true
                }
                return false
              }
            );
            // Check if parent has data-visual-appendChild
            parentWithAppendChild = e.target.parentElement.hasAttribute('data-visual-appendchild') && e.target.parentElement;

            // Check sibling for data-visual-insertBefore
            siblingWithInsertBefore = e.target.parentElement && Array.from(e.target.parentElement.children).filter(
              child => child.hasAttribute('data-visual-insertbefore')
            );

          }



          console.log(JSON.stringify([...fieldsetSiblings, ...siblingsWithDuplicate]));



          // Add entries for data-visual-duplicate siblings
          const existingIds = []
          for (const sibling of siblingsWithDuplicate) {
            console.log('taag' + sibling.tagName)
            let name = `➕ ${sibling.tagName.toLowerCase()}`
            if (sibling.hasAttribute('data-visual-title')) {
              name = `➕ ${sibling.getAttribute('data-visual-title')}`
            }
            const splited = sibling.id.split(':')
            splited.length > 1 && splited.pop()

            if (!existingIds.includes(splited.join(':'))) {
              existingIds.push(splited.join(':'))
              addMenuEntry(menu, name, () => {

                handleMenuEntryClick(e.target.id, sibling.id, siblingWithInsertBefore, parentWithAppendChild);


              });
            }
          }

          // Add entries for fieldset siblings
          for (const fieldsetSibling of fieldsetSiblings) {
            let name = `➕ ${fieldsetSibling.children[0].textContent.toLowerCase()}`
            if (fieldsetSibling.hasAttribute('data-visual-title')) {
              name = `➕ ${fieldsetSibling.getAttribute('data-visual-title')}`
            }
            const splited = fieldsetSibling.id.split(':')
            splited.length > 1 && splited.pop()

            if (!existingIds.includes(splited.join(':').replace('-fieldset', ''))) {
              existingIds.push(splited.join(':').replace('-fieldset', ''))
              addMenuEntry(menu, name, () => {

                handleMenuEntryClick(e.target.id, fieldsetSibling.children[1].id, siblingWithInsertBefore, parentWithAppendChild, true);
              });
            }

          }
          console.log('existing ' + JSON.stringify(existingIds))

          // Adjust the position relative to the viewport
          const offsetX = e.pageX;
          const offsetY = e.pageY;

          menu.style.display = 'block';
          menu.style.left = `${offsetX}px`;
          menu.style.top = `${offsetY}px`;

          // Hide the menu when clicking the left mouse button
          window.addEventListener('click', function () {
            menu.style.display = 'none';
          });
          addMenuEntry(menu, `🗑 Remove element`, async () => {
            if (findRelatedElements(e.target.id) > 1) {
              await pushAction({
                time: (new Date()).getTime(),
                action: 'removeTag',
                target_element: e.target.id + '-tree',

              })
              const el = getElementById1(e.target.id + '-fieldset')
              if (el) {
                el.remove()
              }
            }
            else {
              console.log('iiid ' + e.target.id)
              const attr = e.target.getAttribute('data-visual-defaultTextNode')
              console.log('attr' + attr)
              e.target.textContent = attr
            }

          }
          );
        }
      }

      function handleMenuEntryClick(sourceId, targetId, siblingWithInsertBefore, parentWithAppendChild, flag) {
        console.log('t');
        console.log(parentWithAppendChild);
        console.log(siblingWithInsertBefore);
        removeButtons()
        const original = getElementById1(sourceId);
        const originalRect = original.getBoundingClientRect();
        var iframe = getElementById1("generated-page-iframe");
        var iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
        // Check if siblingWithInsertBefore is present
        if (siblingWithInsertBefore.length > 0) {
          // Insert <button class="receive-target">➕</button> before each siblingWithInsertBefore
          siblingWithInsertBefore.forEach(sibling => {
            const addButton = document.createElement('button');
            addButton.className = 'receive-target';
            addButton.innerHTML = '➕';
            addButton.onclick = function () {
              insertBefore(sibling.id, targetId, flag);
              iframeDocument.removeEventListener('click', clickRemoveButton);
              iframeDocument.addEventListener('mouseover', handleMouseOver);
            };
            iframeDocument.addEventListener('mouseover', handleMouseOver1);
            iframeDocument.addEventListener('mouseout', handleMouseOut1);
            sibling.parentNode.insertBefore(addButton, sibling);
          });
        }

        // Check if parentWithAppendChild is present
        if (parentWithAppendChild) {
          // Append <button class="receive-target">➕</button> to parentWithAppendChild
          const addButton = document.createElement('button');
          addButton.className = 'receive-target';
          addButton.innerHTML = '➕';
          addButton.onclick = function () {
            const children = getElementById1(parentWithAppendChild.id).children;

            let lastFieldsetTreeId = null;

            for (let i = children.length - 1; i >= 0; i--) {
              const child = children[i];
              console.log(child.id)

              if (!child.classList.contains('receive-target')) {
                lastFieldsetTreeId = child.id;
                break; // Found the last matching element, exit the loop
              }
            }

            if (lastFieldsetTreeId !== null) {
              console.log('Last fieldset with id ending in -tree:', lastFieldsetTreeId);
            } else {
              console.log('No matching fieldset with id ending in -tree found.');
            }
            console.log(lastFieldsetTreeId)

            insertAfter(lastFieldsetTreeId, targetId, flag);
            iframeDocument.removeEventListener('click', clickRemoveButton);
            iframeDocument.addEventListener('mouseover', handleMouseOver);
          };
          addButton.addEventListener('mouseover', handleMouseOver1);
          addButton.addEventListener('mouseout', handleMouseOut1);
          parentWithAppendChild.appendChild(addButton);
        }
        iframeDocument.removeEventListener('mouseover', handleMouseOver);
        iframeDocument.addEventListener('click', clickRemoveButton);
        const newElement = getElementById1(sourceId);
        const newRect = newElement.getBoundingClientRect();
        window.scrollTo({
          top: newRect.top - originalRect.top + window.scrollY,
          behavior: 'auto' // You can use 'auto' or 'smooth' for smooth scrolling
        });
        // You can perform additional actions here if needed
      }

      function handleMouseOver1(e) {
        e.target.classList.add('drag-over'); // Add a class to apply hover effect
      }

      function handleMouseOut1(e) {
        e.target.classList.remove('drag-over'); // Remove the class to stop hover effect
      }



      // Example function, adjust as needed
      async function insertBefore(nextElementId, selectedElementId, flag) {
        const actionObject = {
          time: (new Date()).getTime(),
          action: 'InsertBefore',
          target_element: nextElementId.replace('-fieldset', '') + '-tree',
          inserted_element: { originalId: selectedElementId + '-tree', id: duplicateId(selectedElementId).id },
        };
        await pushAction(actionObject, false, flag);
        removeReceiveButtons();
      }

      // Example function, adjust as needed
      async function insertAfter(nextElementId, selectedElementId, flag) {
        const actionObject = {
          time: (new Date()).getTime(),
          action: 'InsertAfter',
          target_element: nextElementId.replace('-fieldset', '') + '-tree',
          inserted_element: { originalId: selectedElementId + '-tree', id: duplicateId(selectedElementId).id },
        };
        await pushAction(actionObject, false, flag);
        removeReceiveButtons();
      }

      // Example function, adjust as needed
      async function append(parentId, selectedElementId, flag) {
        // Perform additional actions if needed
        const actionObject = {
          time: (new Date()).getTime(),
          action: 'Append',
          target_element: parentId + '-tree',
          inserted_element: { originalId: selectedElementId + '-tree', id: duplicateId(selectedElementId).id },
        };
        await pushAction(actionObject, false, flag);
        removeReceiveButtons();
      }


      // Function to remove all elements with the class 'receive-target'
      function removeReceiveButtons() {
        const buttonsToRemove = querySelectorAll1('.receive-target');
        buttonsToRemove.forEach(button => {
          button.parentNode.removeChild(button);
        });
      }
      function moveItem(parentId, selectedElementId, action) {

        // Create a new element (adjust this part based on your requirements)

        // Perform additional actions if needed



        let lastFieldsetTreeId = null;
        let actionObject
        if (action === 'InsertAfter') {
          const children = getElementById1(parentId).children;

          for (let i = children.length - 1; i >= 0; i--) {
            const child = children[i];
            console.log(child.id)
            if (child.tagName === 'FIELDSET' && child.id.endsWith('-fieldset')) {
              lastFieldsetTreeId = child.id;
              break; // Found the last matching element, exit the loop
            }
          }

          if (lastFieldsetTreeId !== null) {
            console.log('Last fieldset with id ending in -tree:', lastFieldsetTreeId);
          } else {
            console.log('No matching fieldset with id ending in -tree found.');
          }


          actionObject = {
            time: (new Date()).getTime(),
            action: action,
            target_element: [{ id: lastFieldsetTreeId.replace('-fieldset', '') + '-tree' }, { id: selectedElementId + '-tree' }],
            move: true,
          }
        }
        else {
          actionObject = {
            time: (new Date()).getTime(),
            action: action,
            target_element: [{ id: parentId.replace('-fieldset', '') + '-tree' }, { id: selectedElementId + '-tree' }],
            move: true,
          }
        }

        pushAction(actionObject);
        // Get a NodeList of all elements with the class 'receive-target'
        const buttonsToRemove = querySelectorAll1('.receive-target');

        // Iterate through the NodeList and remove each button
        buttonsToRemove.forEach(button => {
          button.parentNode.removeChild(button);
        });

      }

      // Utility function to add menu entry
      function findRelatedElements(inputId) {
        // Step 1: Remove the -tree suffix

        // Step 2: If it ends with -copy-x, remove that part
        let modifiedId = removeLastOccurrence(inputId, '-tree');
        const el = getElementById1(modifiedId + '-tree')
        console.log('iiie ' + el.id)
        const tag = el.tagName.toLowerCase()
        const splited = modifiedId.split(';')
        const last = splited[splited.length - 1]
        const lastId = last.split(':')[0]
        splited.pop()
        modifiedId = [...splited, lastId].join(';')
        console.log('modfi ' + modifiedId)
        // Step 3: Query for elements starting with the modified ID
        const selector = '[id^="' + modifiedId + '"]';
        const matchingElements = el.parentNode.querySelectorAll(selector);

        // Step 4: Filter to get only elements that end with -tree
        const filteredElements = Array.from(matchingElements)

        return Array.from(filteredElements).length
      }
      function addMenuEntry(menu, text, clickHandler) {
        const entry = document.createElement('div');
        entry.className = 'menu-option';
        entry.innerHTML = text;
        entry.onclick = async (e) => { await clickHandler(e); menu.style.display = 'none' };
        menu.appendChild(entry);
      }
      function saveT(event, previousValue) {
        const id = event.target.id + '-tree'
        const action = 'textContent'
        console.log('ac' + action)



        const textareaValue = event.target.textContent;
        if (textareaValue === previousValue) {
          event.target.removeAttribute('contenteditable')
          return textareaValue
        }
        if (!textareaValue) {

          if (findRelatedElements(event.target.id) > 1) {
            pushAction({
              time: (new Date()).getTime(),
              action: 'removeTag',
              target_element: id,

            })
            const el = getElementById1(event.target.id + '-fieldset')
            if (el) {
              el.remove()
            }
          }
          else {
            console.log('iiid ' + event.target.id)
            const attr = event.target.getAttribute('data-visual-defaultTextNode')
            console.log('attr' + attr)
            event.target.textContent = attr
          }
          return
        }

        const el = {
          time: (new Date()).getTime(),
          action,
          target_element: id,
          value: textareaValue,

        }
        console.log('ac' + JSON.stringify(el))
        pushAction(el)
        event.target.removeAttribute('contenteditable')
        return textareaValue
      }
      function onDoubleClick(e) {
        // Get the element that was double-clicked
        var target = e.target;
        console.log('target ' + target.id)
        // Check if the element has the 'data-visual-contenteditable' attribute

        if (target.hasAttribute('data-visual-contenteditable')) {


          console.log('has attr')
          // Prevent the default double-click behavior
          e.preventDefault();

          // Set the 'contenteditable' attribute to 'true', making the element editable
          target.setAttribute('contenteditable', 'true');

          // Reset the background color of the element
          target.style.backgroundColor = '';

          // Set focus on the editable element
          target.focus();

          let textContent = target.textContent
          target.addEventListener('blur', function (blurEvent) {
            // Call the saveT function when the element loses focus
            textContent = saveT(blurEvent, textContent)
          });
          target.addEventListener('keypress', function (keyPressEvent) {
            if (keyPressEvent.key === 'Enter') {
              keyPressEvent.preventDefault()
              textContent = saveT(keyPressEvent, textContent);
            }
          });
        }
      }
      iframeDocument.addEventListener('dblclick', onDoubleClick);
      // Add an event listener to the entire document to track double-clicks
      iframeDocument.addEventListener('contextmenu', handleContextMenu)
      iframeDocument.addEventListener('change', async function (event) {

        // Check if the target element has the data-visual-checkbox attribute
        if (event.target.hasAttribute('data-visual-checkbox')) {
          // Log the id of the target element and the new value of the checkbox
          console.log('ID:', event.target.id, 'Value:', event.target.checked);
          let el
          if (event.target.checked) {
            el = {
              time: (new Date()).getTime(),
              action: 'setAttribute',
              target_element: event.target.id,
              key: "checked",
              value: 'true',

            }
          }
          else {
            el = {
              time: (new Date()).getTime(),
              action: 'removeAttribute',
              target_element: event.target.id,
              key: "checked"
            }
          }
          await pushAction(el)
        }
      });



      // Function to check if an element has the 'data-visual-draggable' attribute
      function isDraggable(element) {
        return element.hasAttribute('data-visual-draggable');
      }

      function handleDragStart(e) {
        if (isDraggable(e.target)) {

          console.log('draggable');
          removeButtons()
          e.dataTransfer.setData('text/plain', e.target.id);
          const original = getElementById1(e.target.id);
          const originalRect = original.getBoundingClientRect();
          let siblingWithInsertBefore
          let parentWithAppendChild

          if (
            e.target.parentElement.id === e.target.id + '-fieldset') {
            // Check sibling for data-visual-insertBefore
            siblingWithInsertBefore = e.target.parentElement.parentElement && Array.from(e.target.parentElement.parentElement.children).filter(
              child => child.hasAttribute('data-visual-insertbefore') || (child.id.endsWith('-fieldset') && child.children[1].hasAttribute('data-visual-insertbefore'))
            );

            // Check if the parent has data-visual-appendchild
            parentWithAppendChild = e.target.parentElement.parentElement.hasAttribute('data-visual-appendchild') && e.target.parentElement.parentElement;

          }
          else {
            // Check sibling for data-visual-insertBefore
            siblingWithInsertBefore = e.target.parentElement && Array.from(e.target.parentElement.children).filter(
              child => child.hasAttribute('data-visual-insertbefore')
            );

            // Check if the parent has data-visual-appendchild
            parentWithAppendChild = e.target.parentElement.hasAttribute('data-visual-appendchild') && e.target.parentElement;
          }
          siblingWithInsertBefore.forEach(sibling => {
            // Create the "+" button element with data attributes
            const previousSibling = sibling.previousElementSibling;
            if (previousSibling && previousSibling.id.replace('-fieldset', '') === original.id) {
              return;
            }
            if (sibling.id.replace('-fieldset', '') === original.id) {
              return
            }
            const plusButton = createButton('InsertBefore', sibling.id);
            sibling.parentNode.insertBefore(plusButton, sibling);
            addHoverListeners(plusButton);
          });

          if (parentWithAppendChild && parentWithAppendChild.lastElementChild.id !== e.target.id + '-fieldset') {
            // Create the "+" button element with data attributes
            const plusButton = createButton('InsertAfter', parentWithAppendChild.id);
            parentWithAppendChild.appendChild(plusButton);
            addHoverListeners(plusButton);
          }
          const newElement = getElementById1(e.target.id);
          const newRect = newElement.getBoundingClientRect();
          console.log(window.scrollY)
          console.log(newRect.top)
          console.log(originalRect.top)
          window.scrollTo({
            top: newRect.top - originalRect.top + window.scrollY,
            behavior: 'auto' // You can use 'auto' or 'smooth' for smooth scrolling
          });
          // Update the dragover and drop event listeners
          var iframe = getElementById1("generated-page-iframe");
          var iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
          iframeDocument.addEventListener('dragover', handleDragOver);
          iframeDocument.addEventListener('drop', handleDrop);
        }
      }

      function createButton(action, elementId) {
        const plusButton = document.createElement('button');
        plusButton.className = 'receive-target';
        plusButton.innerHTML = '➕';
        plusButton.setAttribute('data-action', action);
        plusButton.setAttribute('data-element-id', elementId);
        return plusButton;
      }

      function addHoverListeners(plusButton) {
        plusButton.addEventListener('dragenter', handleDragEnter);
        plusButton.addEventListener('dragleave', handleDragLeave);
      }


      function handleDrop(e) {
        e.preventDefault();

        const draggedElementId = e.dataTransfer.getData('text/plain');
        const targetElementId = e.target.getAttribute('data-element-id');
        const action = e.target.getAttribute('data-action');

        // Log the element id and target element id
        console.log(`Element ID: ${draggedElementId}, Target Element ID: ${targetElementId} action ${action}`);
        if (targetElementId) {
          moveItem(targetElementId, draggedElementId, action)
        }

        // Remove the drag-over class from the target element
        if (e.target.classList.contains('receive-target')) {
          e.target.classList.remove('drag-over');
        }


        removeButtons()
        // Reset the dragover and drop event listeners
        document.removeEventListener('dragover', handleDragOver);
        document.removeEventListener('drop', handleDrop);
      }

      function removeButtons() {
        // Remove the "+" button after logging the information
        const plusButtons = querySelectorAll1('.receive-target');
        plusButtons.forEach(button => button.parentNode.removeChild(button));
      }

      function handleDragOver(e) {
        e.preventDefault();

        // Add the drag-over class to the target element
        if (e.target.classList.contains('receive-target')) {
          e.target.classList.add('drag-over');
        }
      }

      function handleDragEnter(e) {
        e.preventDefault();

        // Add the drag-over class to the target element
        if (e.target.classList.contains('receive-target')) {
          e.target.classList.add('drag-over');
        }
      }

      function handleDragLeave(e) {
        // Remove the drag-over class from the target element
        if (e.target.classList.contains('receive-target')) {
          e.target.classList.remove('drag-over');
        }
      }

      iframeDocument.addEventListener('dragstart', handleDragStart);
      visualOn = true
    }

    function processElement(element) {
      // Check if the element has the data-visual-draggable attribute
      if (element.hasAttribute("data-visual-draggable")) {
        // Apply draggable logic here
        element.draggable = true;
      }
      // Check if the element has the data-visual-border attribute
      if (element.hasAttribute("data-visual-border")) {
        // Create a new fieldset element
        var fieldset = document.createElement("fieldset");

        // Set the id of the fieldset to be the id of the original element + "-fieldset"
        fieldset.id = element.id + "-fieldset";
        fieldset.className = "tag-fs";

        // Create a legend element with the content of data-visual-title attribute
        var legend = document.createElement("legend");
        legend.className = "comment";
        legend.textContent = element.getAttribute("data-visual-title");

        // Append the legend to the fieldset
        fieldset.appendChild(legend);

        // Replace the current element with the new fieldset
        element.parentNode.replaceChild(fieldset, element);
        fieldset.appendChild(element);

        // Process nested children
        var nestedChildren = element.children;
        for (var i = 0; i < nestedChildren.length; i++) {
          processElement(nestedChildren[i]);
        }
      } else {
        // Process nested children if the element doesn't have the attribute
        var children = element.children;
        for (var i = 0; i < children.length; i++) {
          processElement(children[i]);
        }
      }
    }
    function handlePathSelection() {
      // Get the selected value from the pathSelector
      var selectedValue = getElementById1('pathSelector').value;
      console.log(selectedValue)
      // Get the corresponding item based on the selected value
      var selectedItem = selectedValue

      // Handle the selected item as needed
      console.log('Selected Item:', selectedItem);
      if (selectedItem === 'select' || selectedItem === undefined) {
        return
      }
      if (selectedItem === 'back') {
        if (path === '') {
          return
        }
        const splited = path.split('/')
        if (splited.length === 1) {
          loadFileList()
          return
        }
        splited.pop()
        path = splited.join('/')
        loadUsingPath()
        return
      }
      if (path === '') {
        path = selectedItem
      }
      else {
        path = path + '/' + selectedItem

      }
      console.log(path)
      loadUsingPath()

    }
    function selectFile(event, fileId, name) {
      // Add logic to handle the selected file, if needed
      console.log('File selected with ID:', fileId);
      var el = event.target;

      // Get the parent fieldset
      var fieldset = el.closest('fieldset');

      // Get the id and action attributes
      var fieldsetId = fieldset.id;
      var fieldsetAction = fieldset.getAttribute('action');

      // Log the id and action attributes (you can replace this with your desired logic)
      console.log("Fieldset ID:", fieldsetId);
      console.log("Fieldset Action:", fieldsetAction);
      const actionObject = {
        time: (new Date()).getTime(),
        action: 'Add_Component',
        subAction: fieldsetAction,
        target_element: fieldsetId.split(';')[1],
        inserted_component: { componentId: fileId, id: generateUUID() },
      };
      pushAction(actionObject);
      // Remove the parent fieldset
      fieldset.remove();
    }
    function loadFileList() {
      // Fetch GET request
      fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?ownerUUID=path&gsi1lsi1=true')
        .then(response => response.json())
        .then(data => {
          // Replace existing file paths with dynamic content
          var fileListTable = getElementById1('code-tree-tag-attributes-form-attributes-list');
          fileListTable.innerHTML = '';

          let i = 0;
          data.items.forEach(item => {

            if (!lvls.includes(item.lsi1.split('/')[0])) {
              lvls.push(item.lsi1.split('/')[0])
            }
            if (i < 25) {
              i++
              // Clone the fieldset
              var newRow = fileListTable.insertRow();
              newRow.innerHTML = `
            <td><button onclick="selectFile(event,'${item.id}','${item.lsi1.split(';')[0]}')">✅select</button></td>
            <td>📂 ${item.lsi1}</td>
            <td><label>🧩</label></td>
          `;
            }

          });

          // Show the cloned fieldsets
          querySelectorAll1('#filePathList fieldset').forEach(fieldset => {
            fieldset.id !== 'cancelation' && fieldset.removeAttribute('hidden');
          });



          // Update select options

        })
        .catch(error => console.error('Error:', error));

    }
    const loadUsingPath = () => {
      return fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?ownerUUID=path&gsi1lsi1=true&lsi1=' + path)
        .then(response => response.json())
        .then(data => {
          // Replace existing file paths with dynamic content
          var fileListTable = getElementById1('code-tree-tag-attributes-form-attributes-list');
          fileListTable.innerHTML = '';
          lvls = []
          let i = 0
          data.items.forEach(item => {

            if (!lvls.includes(item.lsi1.replace(path + '/', '').split('/')[0])) {
              lvls.push(item.lsi1.replace(path + '/', '').split('/')[0])
            }
            if (i < 25) {
              i++
              var newRow = fileListTable.insertRow();
              newRow.innerHTML = `
            <td><button onclick="selectFile(event,'${item.id}')">✅select</button></td>
            <td>📂 ${item.lsi1}</td>
            <td><label>🧩</label></td>
          `;
            }

          });

          // Show the cloned fieldsets
          querySelectorAll1('#filePathList fieldset').forEach(fieldset => {
            fieldset.id !== 'cancelation' && fieldset.removeAttribute('hidden');
          });



          // Update select options

        })
        .catch(error => console.error('Error:', error));
    }
  </script>
  <script>
    var memData = {}
    //third menu 
    const addNew = (e) => {
      const splited = e.target.parentNode.id.split(';')
      const [toRemove, ...rest] = splited
      const parentId = rest.join(';');
      const fieldset = getElementById1('tag-table');

      if (!e.target.parentNode.nextElementSibling || !e.target.parentNode.nextElementSibling.id.startsWith('tag-table')) {
        const clonedFieldset = fieldset.cloneNode(true);

        const clonedRows = clonedFieldset.getElementsByTagName('tbody')[0].getElementsByTagName('tr');
        for (let i = 0; i < clonedRows.length; i++) {
          const index = i; // Capture the current value of 'i' in a closure
          clonedRows[i].onclick = function (event) {
            chooseTag(index, event);
          };
        }
        clonedFieldset.id = clonedFieldset.id + ';' + parentId;
        clonedFieldset.setAttribute('action', e.target.parentNode.getAttribute('action'))
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset);
        e.target.parentNode.remove()
      }
    }
    const addExisting = (e) => {
      const splited = e.target.parentNode.id.split(';')
      const [toRemove, ...rest] = splited
      const parentId = rest.join(';');
      const fieldset = getElementById1('code-tree-append-or-insert-approv-menu');

      if (!e.target.parentNode.nextElementSibling || !e.target.parentNode.nextElementSibling.id.startsWith('code-tree-append-or-insert-approv-menu')) {
        const clonedFieldset = fieldset.cloneNode(true);

        clonedFieldset.id = clonedFieldset.id + ';' + parentId;
        const action = e.target.parentNode.getAttribute('action')
        clonedFieldset.setAttribute('action', action)
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset);
        e.target.parentNode.remove()
        // Get all fieldsets with data-element="code-tree-tag"
        var codeTreeTagFieldsets = querySelectorAll1('fieldset[data-element="code-tree-tag"]');
        var checkbox1 = clonedFieldset.querySelector('#code-tree-menu-dublicate-with-parent-option');
        if (checkbox1 && action === 'InsertBefore') {
          clonedFieldset.querySelector('#code-tree-menu-dublicate-with-parent-option-1').setAttribute('hidden', "");
          clonedFieldset.querySelector('#code-tree-menu-dublicate-with-parent-option-2').setAttribute('hidden', "");
          checkbox1.setAttribute('hidden', "");
        }
        // Iterate through each fieldset and make their checkboxes visible
        codeTreeTagFieldsets.forEach(function (fieldset) {
          var checkbox = fieldset.querySelector('input[type="checkbox"]');
          if (checkbox) {
            checkbox.removeAttribute('hidden');
          }
        });
      }

    }
    const choseComponent = async (e) => {
      const splited = e.target.parentNode.id.split(';')
      const [toRemove, ...rest] = splited
      const parentId = rest.join(';');
      const fieldset = getElementById1('code-tree-tag-attributes-form');

      if (!e.target.parentNode.nextElementSibling || !e.target.parentNode.nextElementSibling.id.startsWith('code-tree-tag-attributes-form')) {
        const clonedFieldset = fieldset.cloneNode(true);

        clonedFieldset.id = clonedFieldset.id + ';' + parentId;

        clonedFieldset.setAttribute('action', e.target.parentNode.getAttribute('action'))
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset);
        await loadFileList()
        e.target.parentNode.remove()
        // Get all fieldsets with data-element="code-tree-tag"

      }
    }


  </script>


  <script>
    var actionLog = []
    var selected = []
    var components = []
    function toggleSubFields(event) {
      // Get the clicked button and its content
      const button = event.target;
      const buttonContent = button.innerHTML;

      // Get the parent fieldset
      const parentFieldset = button.closest('fieldset[data-element="code-tree-tag"]');

      if (parentFieldset) {
        // Find all sub fieldsets inside the parent fieldset
        const subFieldsets = parentFieldset.querySelectorAll('fieldset[data-element="code-tree-tag"]');

        // Check if there are sub fieldsets
        if (subFieldsets.length > 0) {
          // Toggle the visibility of sub fieldsets
          subFieldsets.forEach(subFieldset => {
            subFieldset.hidden = !subFieldset.hidden;
          });

          // Toggle the button content
          button.innerHTML = buttonContent === '→' ? '↓' : '→';
        }
      }
    }
    function handleCheckboxChange(event) {
      var checkbox = event.target;
      var fieldsetId = checkbox.parentNode.id;

      if (checkbox.checked) {
        // Add the ID to the selected array
        selected.push(fieldsetId);
      } else {
        // Remove the ID from the selected array
        var index = selected.indexOf(fieldsetId);
        if (index !== -1) {
          selected.splice(index, 1);
        }
      }

      // Update the content of the span with the length of the selected array
      var amountSelectedSpan = getElementById1('code-tree-amount-selected-for-append-or-insert');
      if (amountSelectedSpan) {
        amountSelectedSpan.textContent = selected.length;
      }

      // Log the selected array (you can replace this with your desired logic)
      console.log("Selected Fieldsets:", selected);
      var arrowButton = checkbox.parentNode.querySelector('[data-element="code-tree-show-hide-button"]');
      if (checkbox.checked) {
        arrowButton.textContent = '↓';
      }
      else {
        arrowButton.textContent = '→';
      }
      // Hide all subfieldsets and enable their checkboxes
      hideSubFieldsets(checkbox.parentNode, checkbox.checked);
    }
    function hideSubFieldsets(parentFieldSet, hide) {
      // Get all fieldsets with data-element="code-tree-tag" under the specified parent
      var subFieldsets = parentFieldSet.querySelectorAll('fieldset[data-element="code-tree-tag"]');

      // Iterate through each subfieldset and toggle visibility
      subFieldsets.forEach(function (subFieldset) {
        // Toggle visibility using the hidden attribute
        subFieldset.hidden = hide;

        // Enable or disable the checkbox based on the hide parameter
        var subCheckbox = subFieldset.querySelector('input[type="checkbox"]');
        if (subCheckbox) {
          subCheckbox.disabled = false;
        }

        // If hiding, remove the subFieldsetId from the selected array
        if (hide) {
          var subFieldsetId = subFieldset.id;
          var index = selected.indexOf(subFieldsetId);
          if (index !== -1) {
            selected.splice(index, 1);
          }
        }


      });
    }
    function generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = Math.random() * 16 | 0,
          v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }
    async function deleteAction(e) {

      event.preventDefault();

      // Access the parent element of the clicked button
      const parentRow = event.target.closest('tr');

      if (parentRow) {
        // Find the span with id "code-log-action-time" within the parent element
        //delete action from db
        await deleteActionFromDb(parentRow)
        location.reload();
      }


      //regenerate page
    }
    function deleteActionFromLog(row) {
      row.remove()
      //add remove to next
    }
    async function deleteActionFromDb(parentRow) {
      const actionTimeElement = parentRow.querySelector('#code-log-action-time');

      if (actionTimeElement) {
        // Retrieve the action time value
        const actionTime = actionTimeElement.textContent;

        // Construct the URL for the delete request
        const urlSearchParams = new URLSearchParams(window.location.search);
        const id = urlSearchParams.get('id');
        const deleteUrl = `https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2/${id}:${actionTime}`;

        try {
          // Send the delete request using the fetch API
          const response = await fetch(deleteUrl, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
              // Add any additional headers if needed
            },
            // You can include a request body if necessary
            // body: JSON.stringify({ action: actionName }),
          });

          if (response.ok) {
            // Delete was successful, you can handle the response or perform additional actions
            console.log('Action deleted successfully');
          } else {
            // Delete request failed, handle the error
            console.error('Error deleting action:', response.statusText);
          }
        } catch (error) {
          // An error occurred while processing the request
          console.error('Error:', error.message);
        }
      }
    }
    const pushAction = async (element, firstLoad, visual, replaceActions, containerId, noComp1, noSubComp1, lvl, removeActions, replaceId) => {
      console.log('pushed' + JSON.stringify(element))
      const time = element.time
      console.log('time' + time)
      actionLog.push(element)
      !firstLoad && await pushActionToDb(element)
      if (element.action !== 'Replace_Component') {
        await insertDataIntoCodeLog(time, element.action)
      }


      await executeCommand(element, '', visual, replaceActions, containerId, noComp1, noSubComp1, lvl, removeActions, replaceId)
    }
    const pushActionToDb = async (action) => {
      const urlSearchParams = new URLSearchParams(window.location.search);
      const id = urlSearchParams.get('id');
      const sk = action.time.toString()
      delete action.time
      const payload = { ...action, sk, id };



      // Send a POST request using fetch
      const response = await fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      // Ensure the request was successful (status code 2xx)
      if (!response.ok) {
        throw new Error(`Failed to push action to the database. Status: ${response.status}`);
      }

      // Parse and log the response or handle it as needed
      const responseData = await response.json();
    }
    function insertDataIntoCodeLog(actionTime, actionName, inserted_component) {
      const originalElement = getElementById1("code-log-element");
      const clonedElement = originalElement.cloneNode(true);
      clonedElement.removeAttribute('hidden')
      // Remove the unwanted button from the cloned element
      const removeButtonCell = originalElement.querySelector("[data-type-code-log='action-remove']");
      if (removeButtonCell) {
        //removeButtonCell.parentNode.removeChild(removeButtonCell);
      }

      // Set the content and attributes for the cloned element
      clonedElement.removeAttribute("hidden");
      clonedElement.querySelector("#code-log-action-time").textContent = actionTime;
      if (inserted_component) {
        console.log('iiiiiiiiiiin0')
        clonedElement.querySelector("#code-log-action").textContent = '🧩' + inserted_component.name;
      }
      else {
        clonedElement.querySelector("#code-log-action").textContent = actionName;
      }

      // Get the parent of the original element
      const parent = originalElement.parentNode;

      // Insert the cloned element before the original element
      parent.insertBefore(clonedElement, originalElement);
    }
    function removeTextNodes(element) {
      for (let i = 0; i < element.childNodes.length; i++) {
        const node = element.childNodes[i];
        if (node.nodeType === Node.TEXT_NODE) {
          element.removeChild(node);
        }
      }
    }
    const executeCommand = async (command, path, visual, replaceActions, containerId, noComp1, noSubComp1, lvl, removeActions, replaceId) => {
      const { subAction, noSubComp, noComp, time, withParent, move, action, target_element, insertedCode, tag_change, inserted_element, key, value, inserted_component } = command;
      let treeElement
      let componentElement

      console.log('command is ' + JSON.stringify(command) + ' replace id ' + replaceId)
      function handleAppendOrInsert(action, selectedArrayNotSorted, move) {
        // Sort

        console.log('start')
        var firstElementId = selectedArrayNotSorted[0];
        var restOfElements = selectedArrayNotSorted.slice(1);
        const removeSelected = (arr) => {
          for (const el of arr) {
            console.log('1- ' + el)
            const treeEl = getElementById1(el)
            const box = treeEl?.querySelector('#selectedCheckbox')
            if (box) {
              console.log('d55')
              box.checked = false
            }
          }
        }
        removeSelected(restOfElements)
        if (components.includes(firstElementId.replace('-tree', ''))) {
          console.log('in555')
          const target = getElementById1(firstElementId)
          for (const el of restOfElements) {
            const toM = getElementById1(el)
            if (action === 'Append') {
              target.append(toM)
            }
            else {
              target.parentNode.insertBefore(toM, target)
            }
          }
          return

        }
        // Sort the rest of the elements by their order in the DOM
        function sortByPlace(a, b) {
          var elementA = getElementById1(a);
          var elementB = getElementById1(b);
          console.log('prob66 ' + a)
          return Array.from(elementA.parentElement.children).indexOf(elementA) -
            Array.from(elementB.parentElement.children).indexOf(elementB);
        }
        function sortByPlace1(a, b) {
          var elementA = a
          var elementB = b

          return Array.from(elementA.parentElement.children).indexOf(elementA) -
            Array.from(elementB.parentElement.children).indexOf(elementB);
        }
        console.log(JSON.stringify(restOfElements))
        restOfElements.sort(sortByPlace);
        if (!move) {
          restOfElements = restOfElements.map(el => removeLastOccurrence(el, '-tree')).map(el =>
            getWithoutCopyId1(el)
          )
          console.log('rest ELS' + JSON.stringify(restOfElements))
          restOfElements = removeDuplicates(restOfElements)
        }

        // Combine the sorted array with the first element
        var selectedArray = [firstElementId, ...restOfElements];

        // Find the target fieldset based on the ID
        var targetElementId = selectedArray[0];
        console.log('selected' + JSON.stringify(selectedArray))
        // Find the target fieldset based on the ID


        const handle = (targetFieldset, targetFieldset2, flag) => {
          console.log('target id' +targetFieldset?.id + targetFieldset2?.id)
          console.log('handling')
          console.log('handling move' + move)
          // Get the parent fieldset of the target
          var parentFieldset = targetFieldset.parentNode;
          var parentFieldset2 = targetFieldset2?.parentNode

          const data_replaceid = targetFieldset2.getAttribute('data-replaceID')
          // Get the index of the target fieldset within its parent
          var index = Array.from(parentFieldset.children).indexOf(targetFieldset);
          var index2 = Array.from(parentFieldset2.children).indexOf(targetFieldset2);
          const treeEls = []
          const compEls = []
          // Iterate through the selected array (skipping the first element, which is the target)
          for (var i = 1; i < selectedArray.length; i++) {
            var selectedId = selectedArray[i].id;
            var originalId = selectedArray[i].originalId
            console.log(JSON.stringify(selectedArray[i]))
            if (!move) {
              console.log('not moving' + JSON.stringify(selectedArrayNotSorted))
              const attr = data_replaceid
              const l = selectedId.split(';').length
              // Find all elements based on the selected ID and its replacement
              var selectedElements = []
              var selectedElements2 = []
              function getContainer() {
                return document
                return containerId ? getElementById1(containerId) : document
              }
              querySelectorAll1('[id^="' + selectedId.split(':')[0] + '"]').forEach(el => {
                if ((!attr || attr === el.getAttribute('data-replaceID')) && !el.id.endsWith('-tree') && !el.id.endsWith('-fieldset')) {
                  selectedElements.push(getElementById1(el.id + '-tree'));
                  selectedElements2.push(el)
                }

              });
              console.log('ppp ' + Array.from(selectedElements).map(e => e?.id))
              console.log('ppp ' + Array.from(selectedElements2).map(e => e?.id))

              selectedElements = selectedElements.filter(el => el.id.split(';').length === l)
              selectedElements2 = selectedElements2.filter(el => el.id.split(';').length === l)
              treeEls.push(...selectedElements)
              compEls.push(...selectedElements2)
              // Iterate through each selected element and process it

            }
            else {
              console.log('moving')
              selectedId = selectedArray[i]
              const treeEl = getElementById1(selectedId)
              let pageEl = getElementById1(removeLastOccurrence(selectedId, '-tree') + '-fieldset')
              if (!pageEl) {
                console.log('true11')
                pageEl = getElementById1(removeLastOccurrence(selectedId, '-tree'))
              }



              var clonedFieldset = cloneWithDescendants(treeEl);
              var arrowButton = clonedFieldset.querySelector('[data-element="code-tree-show-hide-button"]');

              arrowButton.textContent = '→';
              var clonedFieldset2 = cloneWithDescendants(pageEl);
              if (action === 'Append') {
                targetFieldset.appendChild(clonedFieldset);
                if (targetFieldset2.parentNode.id.startsWith(targetFieldset2.id)) {
                  targetFieldset2.parentNode.appendChild(clonedFieldset2);
                }
                else {
                  targetFieldset2.appendChild(clonedFieldset2);
                }

              } else if (action === 'InsertBefore') {

                parentFieldset.insertBefore(clonedFieldset, parentFieldset.children[index]);
                index++; // Increment the index to maintain the correct order
                if (targetFieldset2.parentNode.id.startsWith(targetFieldset2.id)) {
                  console.log('5655')
                  parentFieldset2.parentNode.insertBefore(clonedFieldset2, parentFieldset2);
                }
                else {
                  console.log('5777')
                  console.log(targetFieldset2.parentNode.id)
                  console.log(targetFieldset2.id)
                  parentFieldset2.insertBefore(clonedFieldset2, parentFieldset2.children[index2]);
                }

                index2++; // Increment the index to maintain the correct order
              }


              treeEl.remove();
              pageEl.remove()
            }
          }
          console.log('eels12' + JSON.stringify(treeEls.map(e => e.id)))
          if (!move) {
            if (treeEls.length) {
              treeEls.sort(sortByPlace1)
              compEls.sort(sortByPlace1)
              for (const selectedFieldset of treeEls) {
                console.log('found 11' + selectedFieldset.id)
                var clonedFieldset = cloneWithDescendants(selectedFieldset);
                var arrowButton = clonedFieldset.querySelector('[data-element="code-tree-show-hide-button"]');

                arrowButton.textContent = '→';
                // Insert the cloned fieldset based on the action
                if (action === 'Append') {
                  targetFieldset.appendChild(clonedFieldset);
                } else if (action === 'InsertBefore') {

                  parentFieldset.insertBefore(clonedFieldset, parentFieldset.children[index]);
                  index++; // Increment the index to maintain the correct order
                }

                // Remove the original fieldset
                selectedFieldset.remove();
              }
              for (const selectedFieldset2 of compEls) {
                // Clone the selected fieldset and its descendants
                var clonedFieldset2 = cloneWithDescendants(selectedFieldset2);

                // Insert the cloned fieldset based on the action
                if (action === 'Append') {
                  targetFieldset2.appendChild(clonedFieldset2);
                } else if (action === 'InsertBefore') {


                  parentFieldset2.insertBefore(clonedFieldset2, parentFieldset2.children[index2]);
                  index2++; // Increment the index to maintain the correct order
                }

                // Remove the original fieldset
                selectedFieldset2.remove();
              }
            }
            else {
              const s = []
              const s1 = []
              console.log('sss' + selectedArrayNotSorted[1])
              querySelectorAll1('[id^="' + selectedArrayNotSorted[1].replace('-tree', '').split(':')[0] + '"]').forEach(el => {
                console.log('eel' + el.id)
                if (!el.id.endsWith('-tree') && !el.id.endsWith('-fieldset')) {
                  s.push(getElementById1(el.id + '-tree'));
                  s1.push(el)
                }

              });
              console.log('sss' + JSON.stringify(s))
              console.log('sss' + JSON.stringify(s1))
              const selectedFieldset = s[0]
              const selectedFieldset2 = s1[0]

              var clonedFieldset = cloneWithDescendants(selectedFieldset);
              var arrowButton = clonedFieldset.querySelector('[data-element="code-tree-show-hide-button"]');

              arrowButton.textContent = '→';
              // Insert the cloned fieldset based on the action

              var clonedFieldset2 = cloneWithDescendants(selectedFieldset2);
              if (!flag) {
                const splited = clonedFieldset2.id.split(':')
                splited.pop()
                const newId = [...splited, generateUUID()].join(':')
                clonedFieldset2.id = newId
                clonedFieldset.id = newId + '-tree'
              }
              // Insert the cloned fieldset based on the action
              if (action === 'Append') {
                targetFieldset2.appendChild(clonedFieldset2);
                targetFieldset.appendChild(clonedFieldset);
              } else if (action === 'InsertBefore') {


                parentFieldset2.insertBefore(clonedFieldset2, parentFieldset2.children[index2]);
                index2++; // Increment the index to maintain the correct order
                parentFieldset.insertBefore(clonedFieldset, parentFieldset.children[index]);
                index++; // Increment the index to maintain the correct order
              }

              // Remove the original fieldset
              flag && selectedFieldset2.remove();
              // Remove the original fieldset
              flag && selectedFieldset.remove();
            }

          }
        }
        if (getElementById1(targetElementId)) {
          var targetFieldset = getElementById1(targetElementId);

          var targetFieldset2 = getElementById1(removeLastOccurrence(targetElementId, '-tree'));
          handle(targetFieldset, targetFieldset2)
        }
        else {
          console.log('target not found')
          let treeEls = []
          let compEls = []
          const mId = targetElementId.replace('-tree', '').split(':')[0]
          console.log('miiid' + mId)
          const already = []
          querySelectorAll1('[id^="' + mId + '"]').forEach(
            el => {
              if (!el.id.endsWith('-tree') && !el.id.endsWith('-fieldset') && !already.includes(el.getAttribute('data-replaceid'))) {
                treeEls.push(getElementById1(el.id + '-tree'));
                compEls.push(el)
                already.push(el.getAttribute('data-replaceid'))
              }
            }
          );
          for (let i = treeEls.length - 1; i >= 0; i--) {
            console.log('el pushed 1' + treeEls[i].id)
            handle(treeEls[i], compEls[i], i === 0)
          }
        }

      }



      function cloneWithDescendants(element) {
        var clone = element.cloneNode(true);
        var clonedSubFieldsets = clone.querySelectorAll('fieldset[data-element="code-tree-tag"]');
        clonedSubFieldsets.forEach(function (clonedSubFieldset) {
          clonedSubFieldset.hidden = false;
        });
        const buttons = clone.querySelectorAll("[data-element='code-tree-show-hide-button']");

        buttons.forEach(function (button) {
          button.addEventListener('mouseover', mouseOverTree);
          button.addEventListener('mouseout', mouseOutTree);
        });


        return clone;
      }
      console.log("action" + action)
      const getWithoutCopyId = (id) => {
        const splited = id.split(';');
        const splited2 = splited[splited.length - 1].replace('-tree', '').split(':')
        splited.pop()
        const processed1 = [...splited, splited2[0]].join(';')
        return processed1
      }
      const getWithoutCopyId1 = (id) => {
        const splited = id.split(';');
        const splited2 = splited[splited.length - 1].replace('-tree', '').split(':')
        const copyId = splited.pop()
        const processed1 = [...splited, splited2[0]].join(';')
        return { id: processed1, originalId: id }
      }
      !path && (path = '')
      switch (action) {

        case 'Add_Component':
          if (inserted_component.componentId.startsWith('*')) {
            const site = pathItem.lsi1.split('/')[0]
            const modId = inserted_component.componentId.replace('*', '')
            const lsi = site + modId
            const { items } = await fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?ownerUUID=path&gsi1lsi1=true&lsi1=' + lsi)
              .then(response => response.json())
            console.log(lsi)
            console.log(items.map(i=>i.lsi1))
            const item1 = items.find(i => i.lsi1.replace(';publish:published', '') === lsi)
            inserted_component.componentId = item1.id
          }
          else if (inserted_component.componentId.startsWith('#')) {
            const splited = pathItem.lsi1.split('/')
            splited.pop()
            const last = inserted_component.componentId.replace('#', '')
            splited.push(last)
            const lsi = splited.join('/')
            const { items } = await fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?ownerUUID=path&gsi1lsi1=true&lsi1=' + lsi)
              .then(response => response.json())
            console.log('lsi' + lsi)
            console.log(JSON.stringify(items))

            const item1 = items.find(i => i.lsi1.replace(';publish:published', '') === lsi)
            console.log(JSON.stringify(item1))
            inserted_component.componentId = item1.id
          }

          const removeAction = removeActions?.find(e => e.target_element === inserted_component.id + '-tree')
          if (removeAction) {
            console.log('found 115')
            return
          }
          const replaceAction = replaceActions?.findLast(e => e.target_element[0] === inserted_component.id + '-tree')

          //replace
          console.log('selected Actions' + JSON.stringify(replaceAction))
          treeElement = getElementById1(target_element);
          //component
          componentElement = getElementById1('generated-page');


          //const newEl = document.createElement("component");
          //newEl.id = inserted_component.id;
          //console.log('comp idddd' + newEl.id);

          // Check if componentElement and its parent node are valid
          if (componentElement) {
            // Insert newEl as the first child of the parent node
            //componentElement.insertBefore(newEl, componentElement.firstChild);
          } else {
            console.error("Invalid componentElement or parent node.");
          }

          const component_el = getElementById1('component-element')
          const newEl2 = component_el.cloneNode(true)
          const button2 = newEl2.querySelector("[data-element='code-tree-tag-name-button']")
          button2.textContent = '🧩' + inserted_component.id;
          const button = newEl2.querySelector("[data-element='code-tree-show-hide-button']")
          button.addEventListener('mouseover', mouseOverTree);

          button.addEventListener('mouseout', mouseOutTree);

          newEl2.id = inserted_component.id + '-tree'
          if (noSubComp1) {
            newEl2.setAttribute('hidden', '')
          }
          if (subAction === 'Append') {
            treeElement.append(newEl2);
          } else if (subAction === 'InsertBefore') {
            treeElement.parentNode.insertBefore(newEl2, treeElement)
          } else {
            treeElement.parentNode.insertBefore(newEl2, treeElement.parentNode.firstChild);
          }


          console.log('prob' + inserted_component.componentId)
          components.push(inserted_component.id)
          const level = lvl ? lvl + 1 : 2;
          console.log('foundlvl ' + lvl)
          if (replaceAction) {
            await insertDataIntoCodeLog(replaceAction.sk, replaceAction.action)
            console.log('replace action in')
            const toReplace = replaceAction.target_element[0]
            replaceAction.target_element.shift()
            const dontReplaceIndex = replaceAction.target_element.findIndex(e => e.componentId === toReplace)

            let l = replaceAction.target_element.filter(e => e.componentId !== toReplace);
            let i = false;


            for (const el of l) {

              await executeCommand({
                time,
                action: 'InsertBefore',
                target_element: toReplace,
                inserted_component: el,
                noComp: true,
                noSubComp: i
              }, path, visual, replaceActions, undefined, noComp1, noSubComp1, level, removeActions, el.id)
              i = true

            }
            if (dontReplaceIndex === -1) {
              const elementsToRemove = querySelectorAll1(`[id^="${removeLastOccurrence(toReplace, '-tree') + ';'}"]`);
              elementsToRemove.forEach(element => element.remove());
            }
            const el = getElementById1(toReplace)
            el.setAttribute('replaced', JSON.stringify(replaceAction.target_element))
            const el2 = el.querySelector('[data-element="optional-script"]')
            el2.removeAttribute('hidden')
            el2.innerHTML = `🔄${replaceAction.target_element.length}`;
          }

          await loadFromDb(inserted_component.componentId, inserted_component.id, path, command.sk, replaceActions, replaceAction, noComp1 || noComp, noSubComp1, level, removeActions, replaceId)


          break;
        case 'Insert_First':
          treeElement = components.find(i => i === removeLastOccurrence(target_element, '-tree')) ?
            getElementById1('code-tree')
            : getElementById1(target_element)
          //component

          componentElement = components.find(i => i === removeLastOccurrence(target_element, '-tree')) ?
            getElementById1('generated-page')
            : getElementById1(removeLastOccurrence(target_element, '-tree'));
          const newEle = document.createElement(inserted_element.tagName)
          console.log('no comp val' + noComp1)
          console.log('replaceid1 ' + replaceId)
          noComp1 && newEle.setAttribute('data-replaceID', replaceId)
          newEle.id = inserted_element.id
          console.log(newEle.id)
          componentElement.insertBefore(newEle, componentElement.firstChild);
          const component_ele = getElementById1('tree-element')
          const newEle2 = component_ele.cloneNode(true)
          const button22 = newEle2.querySelector("[data-element='code-tree-tag-name-button']")
          button22.textContent = '🏷️' + inserted_element.tagName;
          const button11 = newEle2.querySelector("[data-element='code-tree-show-hide-button']")
          button11.addEventListener('mouseover', mouseOverTree);

          button11.addEventListener('mouseout', mouseOutTree);

          newEle2.id = inserted_element.id + '-tree'
          treeElement.insertBefore(newEle2, treeElement.firstChild);
          break;

        case 'InsertAfter':

          function insertAfter(newNode, referenceNode) {
            if (referenceNode.nextSibling) {
              referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
            } else {
              referenceNode.parentNode.appendChild(newNode);
            }
          }

          //case duplicate insert before  
          if (inserted_element?.originalId) {
            console.log('insert1' + JSON.stringify(command));
            // fieldset
            treeElement = getElementById1(inserted_element?.originalId);
            // component
            componentElement = getElementById1(removeLastOccurrence(inserted_element.originalId, '-tree'));

            // Duplicate the element
            const newEl = componentElement.cloneNode(true);
            //newEl.textContent = newEl.tagName.toLowerCase();
            // Set the id of the duplicated element to inserted_element.id
            newEl.id = removeLastOccurrence(inserted_element.id, '-tree');
            if (newEl.hasAttribute('data-visual-defaultTextNode') && newEl.hasAttribute('data-visual-element')) {
              // Set child's text content to its content
              newEl.innerText = newEl.getAttribute('data-visual-defaultTextNode')
            }
            console.log(newEl.id);

            // Append the duplicated element to the componentElement
            const compEl = getElementById1(removeLastOccurrence(target_element, '-tree'))
            if (visual) {
              insertAfter(newEl, compEl.parentNode);
              processElement(newEl);
            } else {
              insertAfter(newEl, compEl);
            }


            const newId1 = newEl.id.split(':')[newEl.id.split(':').length - 1]

            if (treeElement) {
              // Duplicate the treeElement content
              const newEl2 = treeElement.cloneNode(true);

              // Set the id of the duplicated treeElement to inserted_element.id + '-tree'
              newEl2.id = inserted_element.id;

              // Update the button text in the duplicated treeElement
              const button2 = newEl2.querySelector("[data-element='code-tree-tag-name-button']");

              // Attach event listeners to the buttons in the duplicated treeElement
              const button = newEl2.querySelector("[data-element='code-tree-show-hide-button']");
              button.addEventListener('mouseover', mouseOverTree);
              button.addEventListener('mouseout', mouseOutTree);
              const trEl = getElementById1(target_element)
              // Append the duplicated treeElement to the treeElement's parent
              insertAfter(newEl2, trEl);
              updateChildIdsRecursive(newEl2, newId1, true);
            }


            function updateChildIdsRecursive(element, newId1, tree) {
              const processed = []
              element.querySelectorAll('[id]').forEach(child => {
                const splited = child.id.split(';');
                const splited2 = splited[splited.length - 1].replace('-tree', '').split(':')
                let newSubId = splited2[0] + ':' + newId1
                tree && (newSubId = newSubId + '-tree')
                splited.pop()
                const processed1 = [...splited, splited2[0]].join(';')
                if (processed.find(el => el.startsWith(processed1))) {
                  console.log('status' + processed1)
                  console.log('status2' + JSON.stringify(processed))
                  child.remove()
                }
                else {
                  processed.push(processed1)
                  console.log('proce' + processed1)
                  child.id = [...splited, newSubId].join(';')
                  if (child.hasAttribute('data-visual-defaultTextNode') && child.hasAttribute('data-visual-element')) {
                    // Set child's text content to its content
                    child.innerText = child.getAttribute('data-visual-defaultTextNode')
                  }
                  // Recursively update ids for child's children
                  updateChildIdsRecursive(child, newId1, tree);
                }

              });
            }

            // Update ids of child elements within the duplicated elements recursively
            updateChildIdsRecursive(newEl, newId1);


            break;
          }
          if (target_element?.length) {
            const afterId = target_element[0].id;
            const id = target_element[1].id;
            console.log(id)
            console.log(afterId)
            const aftertreeElement = getElementById1(afterId);
            let aftercomponentElement = getElementById1(removeLastOccurrence(afterId, '-tree') + '-fieldset') ||
              getElementById1(removeLastOccurrence(afterId, '-tree'));

            const treeElement = getElementById1(id);
            let componentElement = getElementById1(removeLastOccurrence(id, '-tree') + '-fieldset') ||
              getElementById1(removeLastOccurrence(id, '-tree'));

            if (aftertreeElement && treeElement) {
              // Move treeElement after aftertreeElement
              insertAfter(treeElement, aftertreeElement);
            }

            if (aftercomponentElement && componentElement) {
              // Move componentElement after aftercomponentElement
              insertAfter(componentElement, aftercomponentElement);
            }
          }

          break;

        case 'Append':
          // Handle the 'Append' action
          if (withParent) {
            // get all copies 
            const handleWithParent = async (id, items) => {
              console.log('input 6' + JSON.stringify(items))
              const [firstId, ...restIds] = items
              for (const el of restIds) {


                async function append(parentId, selectedElementId, flag) {
                  console.log('parent id' + parentId)
                  console.log('el id' + selectedElementId)
                  const { id, copyId } = duplicateId(selectedElementId)
                  // Perform additional actions if needed
                  let actionObject
                  if (getElementById1(selectedElementId + '-tree').nextElementSibling) {
                    actionObject = {
                      time: (new Date()).getTime(),
                      action: 'InsertBefore',
                      target_element: getElementById1(selectedElementId + '-tree').nextElementSibling.id,
                      inserted_element: { originalId: selectedElementId + '-tree', id },
                    };
                  }
                  else {
                    actionObject = {
                      time: (new Date()).getTime(),
                      action: 'Append',
                      target_element: getElementById1(selectedElementId + '-tree').parentNode.id,
                      inserted_element: { originalId: selectedElementId + '-tree', id },
                    };
                  }

                  await executeCommand(actionObject, path, visual);
                  return { t: actionObject.inserted_element.id, copyId }
                }

                const { t, copyId } = await append(removeLastOccurrence(getElementById1(id).parentNode.id, '-tree'), removeLastOccurrence(id, '-tree'))

                await executeCommand({
                  time: (new Date()).getTime(),
                  action: 'Append',
                  target_element: [{ type: 'tag', id: t, }, { type: 'tag', id: el, }],
                  move: true
                }, path, visual);
                console.log('main2' + JSON.stringify([{ type: 'tag', t, }, { type: 'tag', id: el, }]))
              }
              console.log('main1' + JSON.stringify([{ type: 'tag', id, }, { type: 'tag', id: firstId, }]))
              await executeCommand({
                time: (new Date()).getTime(),
                action: 'Append',
                target_element: [{ type: 'tag', id, }, { type: 'tag', id: firstId, }],
                move: true
              }, path, visual);
            }
            const id = target_element[0].id
            target_element.shift()
            let restOfElements = target_element.map(el => removeLastOccurrence(el.id, '-tree')).map(el =>
              getWithoutCopyId(el))
            restOfElements = removeDuplicates(restOfElements)
            if (getElementById1(id)) {





              const items = []
              for (const element of restOfElements) {
                const l = element.split(';').length
                querySelectorAll1('[id^="' + element + '"]').forEach(el => {
                  el.id.endsWith('-tree') && el.id.split(';').length === l && items.push(el.id)
                });
              }
              console.log('iteeems' + JSON.stringify(items))

              handleWithParent(id, items)
            }
            else {
              console.log('prob555')
              const mId = getWithoutCopyId(id)
              let copies = querySelectorAll1('[id^="' + mId + '"]')

              const already = []
              for (const element of copies) {
                if (element.id.endsWith('-tree') || element.id.endsWith('-fieldset')) {
                  continue
                }
                const replaceId = element.getAttribute('data-replaceid')
                console.log('replace id + ' + replaceId)
                const items = []

                for (const element of restOfElements) {
                  const l = element.split(';').length
                  querySelectorAll1('[id^="' + element + '"]').forEach(el => {
                    !el.id.endsWith('-fieldset') && !el.id.endsWith('-tree') && el.id.split(';').length === l && el.getAttribute('data-replaceid') === replaceId && items.push(el.id + '-tree')
                  });
                }
                console.log('prob items 1 ' + JSON.stringify(items))
                const found = items.find(item => !already.find(i => i === item))
                console.log(found)
                already.push(found)
                handleWithParent(element.id + '-tree', items)
              }
            }

            break;
          }
          if (inserted_component) {
            //fieldset
            console.log('in')
            console.log(target_element)
            treeElement = getElementById1(target_element);
            //component

            const component_el = getElementById1('component-element')
            const newEl2 = component_el.cloneNode(true)
            const button2 = newEl2.querySelector("[data-element='code-tree-tag-name-button']")
            button2.textContent = '🧩' + inserted_component.id;
            const button = newEl2.querySelector("[data-element='code-tree-show-hide-button']")
            button.addEventListener('mouseover', mouseOverTree);

            button.addEventListener('mouseout', mouseOutTree);

            newEl2.id = inserted_component.id + '-tree'

            treeElement.appendChild(newEl2)
            console.log('prob' + inserted_component.componentId)
            components.push(inserted_component.id)
            console.log('err ' + path)
            await loadFromDb(inserted_component.componentId, inserted_component.id, path, command.sk, false, noComp1 || noComp)
            break;
          }
          //case duplicate append
          if (inserted_element?.originalId) {
            console.log('insert2' + JSON.stringify(command));
            // fieldset
            treeElement = getElementById1(inserted_element?.originalId);
            // component
            componentElement = getElementById1(removeLastOccurrence(inserted_element.originalId, '-tree'));

            // Duplicate the element
            let newEl = componentElement.cloneNode(true);
            if (newEl.hasAttribute('data-visual-defaultTextNode') && newEl.hasAttribute('data-visual-element')) {
              // Set child's text content to its content
              newEl.innerText = newEl.getAttribute('data-visual-defaultTextNode')
            }
            // Set the id of the duplicated element to inserted_element.id
            newEl.id = removeLastOccurrence(inserted_element.id, '-tree');
            console.log(newEl.id);

            // Append the duplicated element to the componentElement
            if (visual) {
              getElementById1(removeLastOccurrence(target_element, '-tree')).parentNode.appendChild(newEl);
              processElement(newEl)
            }
            else {
              getElementById1(removeLastOccurrence(target_element, '-tree')).appendChild(newEl);
            }
            //processElement(newEl)
            // Duplicate the treeElement content
            const newEl2 = treeElement.cloneNode(true);

            // Set the id of the duplicated treeElement to inserted_element.id + '-tree'
            newEl2.id = inserted_element.id;

            // Update the button text in the duplicated treeElement
            const button2 = newEl2.querySelector("[data-element='code-tree-tag-name-button']");

            // Attach event listeners to the buttons in the duplicated treeElement
            const button = newEl2.querySelector("[data-element='code-tree-show-hide-button']");
            button.addEventListener('mouseover', mouseOverTree);
            button.addEventListener('mouseout', mouseOutTree);

            // Append the duplicated treeElement to the treeElement's parent

            getElementById1(target_element).appendChild(newEl2);

            const newId1 = newEl.id.split(':')[newEl.id.split(':').length - 1]
            function updateChildIdsRecursive(element, newId1, tree) {
              const processed = []
              element.querySelectorAll('[id]').forEach(child => {
                const splited = child.id.split(';');
                const splited2 = splited[splited.length - 1].replace('-tree', '').split(':')
                let newSubId = splited2[0] + ':' + newId1
                tree && (newSubId = newSubId + '-tree')
                splited.pop()
                const processed1 = [...splited, splited2[0]].join(';')
                if (processed.find(el => el.startsWith(processed1))) {
                  console.log('status' + processed1)
                  console.log('status2' + JSON.stringify(processed))
                  child.remove()
                }
                else {
                  processed.push(processed1)
                  console.log('proce' + processed1)
                  child.id = [...splited, newSubId].join(';')
                  if (child.hasAttribute('data-visual-defaultTextNode') && child.hasAttribute('data-visual-element')) {
                    // Set child's text content to its content
                    child.innerText = child.getAttribute('data-visual-defaultTextNode')
                  }
                  // Recursively update ids for child's children
                  updateChildIdsRecursive(child, newId1, tree);
                }

              });
            }

            // Update ids of child elements within the duplicated elements recursively
            updateChildIdsRecursive(newEl, newId1);
            updateChildIdsRecursive(newEl2, newId1, true);
            break;
          }
          //case insert tag
          if (inserted_element?.tagName) {




            const handleInsert = (treeElement, componentElement, replaceCopyId) => {
              console.log('handling' + treeElement + ' ' + componentElement + ' ' + replaceCopyId)
              const newEl = document.createElement(inserted_element.tagName)
              const attr1 = componentElement.getAttribute('data-replaceID')
              if (attr1) {
                newEl.setAttribute('data-replaceID', attr1)
              }
              if (noComp || noComp1) {
                newEl.setAttribute('data-replaceID', replaceId)
              }

              const splited = componentElement.id.split(';')






              newEl.id = replaceCopyId ? inserted_element.id.split(':')[0] + ':' + componentElement.getAttribute('data-replaceid') : inserted_element.id

              console.log(newEl.id)

              const component_el = getElementById1('tree-element')
              const newEl2 = component_el.cloneNode(true)
              const button2 = newEl2.querySelector("[data-element='code-tree-tag-name-button']")
              button2.textContent = '🏷️' + inserted_element.tagName;
              const button = newEl2.querySelector("[data-element='code-tree-show-hide-button']")
              button.addEventListener('mouseover', mouseOverTree);

              button.addEventListener('mouseout', mouseOutTree);
              newEl2.id = replaceCopyId ? inserted_element.id.split(':')[0] + ':' + componentElement.getAttribute('data-replaceid') + '-tree' : inserted_element.id + '-tree'
              if (componentElement.hasAttribute('data-parentid')) {
                console.log('in12')
                newEl.id = componentElement.id + ';' + inserted_element.id
                newEl2.id = componentElement.id + ';' + inserted_element.id + '-tree'
              }

              else if (splited.length > 1) {
                newEl.id = splited[0] + ';' + inserted_element.id
                newEl2.id = splited[0] + ';' + inserted_element.id + '-tree'
              }
              componentElement.appendChild(newEl)
              treeElement.appendChild(newEl2)
            }

            treeElement = components.find(i => i === removeLastOccurrence(target_element, '-tree')) ?
              getElementById1('code-tree')
              : getElementById1(target_element)
            //component
            componentElement = components.find(i => i === removeLastOccurrence(target_element, '-tree')) ?
              getElementById1('generated-page')
              :
              getElementById1(removeLastOccurrence(target_element, '-tree'));
            if (!componentElement) {
              console.log('comp not found')
              const mId = target_element.replace('-tree', '').split(':')[0]
              const treeEls = []
              const compEls = []
              const existing = []
              const elementsWithIdAndAttribute = querySelectorAll1('[id^="' + mId + '"][data-replaceid]')
                .forEach(
                  el => {
                    console.log('ffooound152 ' + el.id)
                    if (!existing.includes(el.getAttribute('data-replaceid'))) {
                      existing.push(el.getAttribute('data-replaceid'))
                      treeEls.push(getElementById1(el.id + '-tree'));
                      compEls.push(el)
                    }

                  }
                );

              for (let i = 0; i < treeEls.length; i++) {
                handleInsert(treeEls[i], compEls[i], true)
              }
              break;
            }
            console.log('handling insert')

            handleInsert(treeElement, componentElement)


            break;








            console.log(command)
            //fieldset
            treeElement = components.find(i => i === removeLastOccurrence(target_element, '-tree')) ?
              getElementById1('code-tree')
              : getElementById1(target_element)
            //component

            componentElement = components.find(i => i === removeLastOccurrence(target_element, '-tree')) ?
              getElementById('generated-page')
              :
              getElementById1(removeLastOccurrence(target_element, '-tree'));

            const newEl = document.createElement(inserted_element.tagName)
            const attr = componentElement.getAttribute('data-replaceID')
            if (attr) {
              newEl.setAttribute('data-replaceID', attr)
            }
            if (noComp1 || noComp) {
              newEl.setAttribute('data-replaceID', replaceId)
            }



            console.log(newEl.id)
            componentElement.appendChild(newEl)
            const component_el = getElementById1('tree-element')
            const newEl2 = component_el.cloneNode(true)
            const button2 = newEl2.querySelector("[data-element='code-tree-tag-name-button']")
            button2.textContent = '🏷️' + inserted_element.tagName;
            const button = newEl2.querySelector("[data-element='code-tree-show-hide-button']")
            button.addEventListener('mouseover', mouseOverTree);

            button.addEventListener('mouseout', mouseOutTree);


            newEl.id = inserted_element.id
            newEl2.id = inserted_element.id + '-tree'
            const splited = componentElement.id.split(';')
            console.log('com1' + componentElement.hasAttribute('data-parentid') + componentElement.id)
            if (componentElement.hasAttribute('data-parentid')) {
              console.log('in12')
              newEl.id = componentElement.id + ';' + inserted_element.id
              newEl2.id = componentElement.id + ';' + inserted_element.id + '-tree'
            }

            else if (splited.length > 1) {
              newEl.id = splited[0] + ';' + inserted_element.id
              newEl2.id = splited[0] + ';' + inserted_element.id + '-tree'
            }
            componentElement.appendChild(newEl)
            treeElement.appendChild(newEl2)
            break;
          }
          if (target_element.length) {
            console.log('movestat ' + move)
            handleAppendOrInsert('Append', target_element.map(i => i.id), move)
          }
          break;

        case 'InsertBefore':
          // Handle the 'InsertBefore' action
          // Handle the 'Append' action
          //fieldset
          if (withParent) {
            // get all copies 
            const handleWithParent = async (id, items) => {
              console.log('input 6' + JSON.stringify(items))
              const [firstId, ...restIds] = items
              for (const el of restIds) {


                async function append(parentId, selectedElementId, flag) {
                  console.log('parent id' + parentId)
                  console.log('el id' + selectedElementId)
                  const { id, copyId } = duplicateId(selectedElementId)
                  // Perform additional actions if needed
                  let actionObject
                  if (getElementById1(selectedElementId + '-tree').nextElementSibling) {
                    actionObject = {
                      time: (new Date()).getTime(),
                      action: 'InsertBefore',
                      target_element: getElementById1(selectedElementId + '-tree').nextElementSibling.id,
                      inserted_element: { originalId: selectedElementId + '-tree', id },
                    };
                  }
                  else {
                    actionObject = {
                      time: (new Date()).getTime(),
                      action: 'Append',
                      target_element: getElementById1(selectedElementId + '-tree').parentNode.id,
                      inserted_element: { originalId: selectedElementId + '-tree', id },
                    };
                  }

                  await executeCommand(actionObject, path, visual);
                  return { t: actionObject.inserted_element.id, copyId }
                }

                const { t, copyId } = await append(removeLastOccurrence(getElementById1(id).parentNode.id, '-tree'), removeLastOccurrence(id, '-tree'))

                await executeCommand({
                  time: (new Date()).getTime(),
                  action: 'InsertBefore',
                  target_element: [{ type: 'tag', id: t, }, { type: 'tag', id: el, }],
                  move: true
                }, path, visual);
                console.log('main2' + JSON.stringify([{ type: 'tag', t, }, { type: 'tag', id: el, }]))
              }
              console.log('main1' + JSON.stringify([{ type: 'tag', id, }, { type: 'tag', id: firstId, }]))
              await executeCommand({
                time: (new Date()).getTime(),
                action: 'InsertBefore',
                target_element: [{ type: 'tag', id, }, { type: 'tag', id: firstId, }],
                move: true
              }, path, visual);
            }
            const id = target_element[0].id
            target_element.shift()
            let restOfElements = target_element.map(el => removeLastOccurrence(el.id, '-tree')).map(el =>
              getWithoutCopyId(el))
            restOfElements = removeDuplicates(restOfElements)
            if (getElementById1(id)) {





              const items = []
              for (const element of restOfElements) {
                const l = element.split(';').length
                querySelectorAll1('[id^="' + element + '"]').forEach(el => {
                  el.id.endsWith('-tree') && el.id.split(';').length === l && items.push(el.id)
                });
              }
              if (!items.length) {
                for (const element of restOfElements) {
                  const mId = getWithoutCopyId(element)
                  console.log('miiid ' + mId)
                  querySelectorAll1('[id^="' + mId + '"]').forEach(el => {
                    console.log('dddd ' + el.id)
                    el.id.endsWith('-tree') && el.id.split(';').length === l && items.push(el.id)
                  });
                }
              }
              console.log('iteeems' + JSON.stringify(items))

              handleWithParent(id, items)
            }
            else {
              console.log('prob555')
              const mId = getWithoutCopyId(id)
              let copies = querySelectorAll1('[id^="' + mId + '"]')

              const already = []
              for (const element of copies) {
                if (element.id.endsWith('-tree') || element.id.endsWith('-fieldset')) {
                  continue
                }
                const replaceId = element.getAttribute('data-replaceid')
                console.log('replace id + ' + replaceId)
                const items = []

                for (const element of restOfElements) {
                  const l = element.split(';').length
                  querySelectorAll1('[id^="' + element + '"]').forEach(el => {
                    !el.id.endsWith('-fieldset') && !el.id.endsWith('-tree') && el.id.split(';').length === l && el.getAttribute('data-replaceid') === replaceId && items.push(el.id + '-tree')
                  });
                }
                console.log('prob items 1 ' + JSON.stringify(items))
                const found = items.find(item => !already.find(i => i === item))
                console.log(found)
                already.push(found)
                handleWithParent(element.id + '-tree', items)
              }
            }
            break;
          }
          if (inserted_component) {
            //fieldset
            if (inserted_component.componentId.startsWith('*')) {
              const site = pathItem.lsi1.split('/')[0]
              const modId = inserted_component.componentId.replace('*', '')
              const lsi = site + modId
              const { items } = await fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?ownerUUID=path&gsi1lsi1=true&lsi1=' + lsi)
                .then(response => response.json())
              const item1 = items.find(i => i.lsi1.replace(';publish:published', '') === lsi)
              inserted_component.componentId = item1.id
            }
            else if (inserted_component.componentId.startsWith('#')) {
              const splited = pathItem.lsi1.split('/')
              splited.pop()
              const last = inserted_component.componentId.replace('#', '')
              splited.push(last)
              const lsi = splited.join('/')
              const { items } = await fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?ownerUUID=path&gsi1lsi1=true&lsi1=' + lsi)
                .then(response => response.json())
              const item1 = items.find(i => i.lsi1.replace(';publish:published', '') === lsi)
              inserted_component.componentId = item1.id
            }
            console.log('in')
            console.log(target_element)
            treeElement = getElementById1(target_element);
            //component
            //componentElement = getElementById1(removeLastOccurrence(target_element, '-tree'));
            //const newEl = document.createElement("div")
            //newEl.id = inserted_component.id
            //console.log(newEl.id)
            //componentElement.appendChild(newEl)
            const component_el = getElementById1('component-element')
            const newEl2 = component_el.cloneNode(true)
            const button2 = newEl2.querySelector("[data-element='code-tree-tag-name-button']")
            button2.textContent = '🧩' + inserted_component.name;
            const button = newEl2.querySelector("[data-element='code-tree-show-hide-button']")
            button.addEventListener('mouseover', mouseOverTree);

            button.addEventListener('mouseout', mouseOutTree);

            newEl2.id = inserted_component.id + '-tree'
            if (noComp || noComp1) {
              console.log('no comp true')
              newEl2.setAttribute('hidden', '')
            }
            treeElement.parentNode.insertBefore(newEl2, treeElement)
            components.push(inserted_component.id)
            console.log(inserted_component.componentId)

            await loadFromDb(inserted_component.componentId, inserted_component.id, path, inserted_component.name, replaceActions, false, noComp || noComp1, noSubComp, lvl, removeActions, replaceId)
            break;
          }
          //case duplicate insert before
          if (inserted_element?.originalId) {
            console.log('insert1' + JSON.stringify(command));
            // fieldset
            treeElement = getElementById1(inserted_element?.originalId);
            // component
            componentElement = getElementById1(removeLastOccurrence(inserted_element.originalId, '-tree'));

            // Duplicate the element
            const newEl = componentElement.cloneNode(true);
            //newEl.textContent = newEl.tagName.toLowerCase();
            // Set the id of the duplicated element to inserted_element.id
            newEl.id = removeLastOccurrence(inserted_element.id, '-tree');
            if (newEl.hasAttribute('data-visual-defaultTextNode') && newEl.hasAttribute('data-visual-element')) {
              // Set child's text content to its content
              newEl.innerText = newEl.getAttribute('data-visual-defaultTextNode')
            }
            console.log(newEl.id);

            // Append the duplicated element to the componentElement
            const compEl = getElementById1(removeLastOccurrence(target_element, '-tree'))
            if (visual) {
              compEl.parentNode.parentNode.insertBefore(newEl, compEl.parentNode);
              processElement(newEl)
            }
            else {
              compEl.parentNode.insertBefore(newEl, compEl);
            }
            const newId1 = newEl.id.split(':')[newEl.id.split(':').length - 1]
            if (treeElement) {
              // Duplicate the treeElement content
              const newEl2 = treeElement.cloneNode(true);

              // Set the id of the duplicated treeElement to inserted_element.id + '-tree'
              newEl2.id = inserted_element.id;

              // Update the button text in the duplicated treeElement
              const button2 = newEl2.querySelector("[data-element='code-tree-tag-name-button']");

              // Attach event listeners to the buttons in the duplicated treeElement
              const button = newEl2.querySelector("[data-element='code-tree-show-hide-button']");
              button.addEventListener('mouseover', mouseOverTree);
              button.addEventListener('mouseout', mouseOutTree);
              const trEl = getElementById1(target_element)
              // Append the duplicated treeElement to the treeElement's parent
              treeElement.parentNode.insertBefore(newEl2, trEl)

              updateChildIdsRecursive(newEl2, newId1, true);
            }

            function updateChildIdsRecursive(element, newId1, tree) {
              const processed = []
              element.querySelectorAll('[id]').forEach(child => {
                const splited = child.id.split(';');
                const splited2 = splited[splited.length - 1].replace('-tree', '').split(':')
                let newSubId = splited2[0] + ':' + newId1
                tree && (newSubId = newSubId + '-tree')
                splited.pop()
                const processed1 = [...splited, splited2[0]].join(';')
                if (processed.find(el => el.startsWith(processed1))) {
                  console.log('status' + processed1)
                  console.log('status2' + JSON.stringify(processed))
                  child.remove()
                }
                else {
                  processed.push(processed1)
                  console.log('proce' + processed1)
                  child.id = [...splited, newSubId].join(';')
                  if (child.hasAttribute('data-visual-defaultTextNode') && child.hasAttribute('data-visual-element')) {
                    // Set child's text content to its content
                    child.innerText = child.getAttribute('data-visual-defaultTextNode')
                  }
                  // Recursively update ids for child's children
                  updateChildIdsRecursive(child, newId1, tree);
                }

              });
            }

            // Update ids of child elements within the duplicated elements recursively
            updateChildIdsRecursive(newEl, newId1);


            break;
          }
          //case insert tag
          if (inserted_element?.tagName) {
            const handleInsert = (treeElement, componentElement, replaceCopyId) => {
              console.log('handling' + treeElement + ' ' + componentElement + ' ' + replaceCopyId)
              const newEl = document.createElement(inserted_element.tagName)
              const attr1 = componentElement.getAttribute('data-replaceID')
              if (attr1) {
                newEl.setAttribute('data-replaceID', attr1)
              }
              if (noComp || noComp1) {
                newEl.setAttribute('data-replaceID', replaceId)
              }

              const splited = componentElement.id.split(';')






              newEl.id = replaceCopyId ? inserted_element.id.split(':')[0] + ':' + componentElement.getAttribute('data-replaceid') : inserted_element.id

              console.log(newEl.id)

              const component_el = getElementById1('tree-element')
              const newEl2 = component_el.cloneNode(true)
              const button2 = newEl2.querySelector("[data-element='code-tree-tag-name-button']")
              button2.textContent = '🏷️' + inserted_element.tagName;
              const button = newEl2.querySelector("[data-element='code-tree-show-hide-button']")
              button.addEventListener('mouseover', mouseOverTree);

              button.addEventListener('mouseout', mouseOutTree);
              newEl2.id = replaceCopyId ? inserted_element.id.split(':')[0] + ':' + componentElement.getAttribute('data-replaceid') + '-tree' : inserted_element.id + '-tree'
              if (splited.length > 1) {
                newEl.id = splited[0] + ';' + newEl.id
                newEl2.id = splited[0] + ';' + newEl2.id
              }
              componentElement.parentNode.insertBefore(newEl, componentElement)
              treeElement.parentNode.insertBefore(newEl2, treeElement)
            }
            treeElement = components.find(i => i === removeLastOccurrence(target_element, '-tree')) ?
              getElementById1('code-tree')
              : getElementById1(target_element)
            //component
            componentElement = components.find(i => i === removeLastOccurrence(target_element, '-tree')) ?
              getElementById1('generated-page')
              :
              getElementById1(removeLastOccurrence(target_element, '-tree'));
            if (!componentElement) {
              console.log('comp not found')
              const mId = target_element.replace('-tree', '').split(':')[0]
              const treeEls = []
              const compEls = []
              const existing = []
              const elementsWithIdAndAttribute = querySelectorAll1('[id^="' + mId + '"][data-replaceid]')
                .forEach(
                  el => {
                    console.log('ffooound152 ' + el.id)
                    if (!existing.includes(el.getAttribute('data-replaceid'))) {
                      existing.push(el.getAttribute('data-replaceid'))
                      treeEls.push(getElementById1(el.id + '-tree'));
                      compEls.push(el)
                    }

                  }
                );

              for (let i = 0; i < treeEls.length; i++) {
                handleInsert(treeEls[i], compEls[i], true)
              }
              break;
            }
            console.log('handling insert')
            handleInsert(treeElement, componentElement)


            break;

          }
          if (target_element.length) {
            console.log(JSON.stringify(target_element))
            handleAppendOrInsert('InsertBefore', target_element.map(i => i.id), move)

          }
          break;



        case 'innerHtml':
          // Handle the 'innerHtml' action
          const targetElement = getElementById1(removeLastOccurrence(target_element, '-tree'));
          targetElement.innerHTML = insertedCode;

          break;
        case 'Replace_Component':
          // Handle the 'innerHtml' action
          //location.reload();
          break;
        /*
        const toReplace = target_element[0]
        target_element.shift()
        const dontReplaceIndex = target_element.findIndex(e => e.componentId === toReplace)
  
        let l = target_element.filter(e => e.componentId !== toReplace);
  
        for (const el of l) {
          if (!el.already) {
            await executeCommand({
              time,
              action: 'InsertBefore',
              target_element: toReplace,
              inserted_component: el,
              noComp: true
            }, path, visual)
          }
  
        }
        if (dontReplaceIndex === -1) {
          const elementsToRemove = querySelectorAll1(`[id^="${removeLastOccurrence(toReplace, '-tree') + ';'}"]`);
          elementsToRemove.forEach(element => element.remove());
        }
        const el = getElementById1(toReplace)
        el.setAttribute('replaced', JSON.stringify(target_element))
        const el2 = el.querySelector('[data-element="optional-script"]')
        el2.removeAttribute('hidden')
        el2.innerHTML = `🔄${target_element.length}`;
        break;
        */


        case 'ChangeTag':
          // Handle the 'ChangeTag' action
          // tree el

          const elementToChange = getElementById1(target_element);
          elementToChange.querySelector("[data-element='code-tree-tag-name-button']").textContent = '🏷️' + tag_change;
          // builder el
          const elementToChange2 = getElementById1(removeLastOccurrence(target_element, '-tree'));
          if (elementToChange2) {
            // Create a new p element
            var newElement = document.createElement(tag_change);

            // Copy attributes from the div to the p element
            for (var i = 0; i < elementToChange2.attributes.length; i++) {
              var attribute = elementToChange2.attributes[i];
              newElement.setAttribute(attribute.name, attribute.value);
            }
            newElement.id = elementToChange2.id
            // Copy content from the div to the p element
            newElement.innerHTML = elementToChange2.innerHTML;

            // Replace the div element with the new p element

            elementToChange2.parentNode.replaceChild(newElement, elementToChange2);
            // Add an event listener to the entire document to track double-clicks



          }
          break;
        case 'ChangeTagForCopies':
          // Handle the 'ChangeTag' action
          // tree el
          const selector1 = '[id^="' + removeLastOccurrence(target_element, '-tree').split(':')[0] + '"]';
          querySelectorAll1(selector1).forEach(e => {

            if (e.id.endsWith('-tree')) {
              e.querySelector("[data-element='code-tree-tag-name-button']").textContent = '🏷️' + tag_change;
            }
            else {
              var newElement = document.createElement(tag_change);

              // Copy attributes from the div to the p element
              for (var i = 0; i < e.attributes.length; i++) {
                var attribute = e.attributes[i];
                newElement.setAttribute(attribute.name, attribute.value);
              }
              newElement.id = e.id
              // Copy content from the div to the p element
              newElement.innerHTML = e.innerHTML;

              // Replace the div element with the new p element

              e.parentNode.replaceChild(newElement, e);
            }
          });

          break;


        case 'dublicateTag':
          // Handle the 'dublicateTag' action
          const originalElement = getElementById1(target_element);
          const originalElement2 = getElementById1(removeLastOccurrence(target_element, '-tree'));
          const duplicatedElement = originalElement.cloneNode(true);
          const duplicatedElement2 = originalElement2.cloneNode(true);
          //to do
          duplicatedElement.id = inserted_element
          duplicatedElement2.id = removeLastOccurrence(inserted_element, '-tree');

          originalElement.parentNode.appendChild(duplicatedElement);
          originalElement2.parentNode.appendChild(duplicatedElement2);
          break;

        case 'removeTag':
          // Handle the 'removeTag' action
          // tree
          const elementToRemove = getElementById1(target_element);
          elementToRemove && elementToRemove.parentNode.removeChild(elementToRemove);

          // component
          const elementToRemove2 = getElementById1(removeLastOccurrence(target_element, '-tree'));
          elementToRemove2 && elementToRemove2.parentNode.removeChild(elementToRemove2);


          break;
        case 'removeTagAndCopies':
          // Handle the 'removeTag' action

          // component
          const selector = '[id^="' + removeLastOccurrence(target_element, '-tree').split(':')[0] + '"]';
          querySelectorAll1(selector).forEach(e => e.remove());



          break;
        case 'removeComponent':
          // Handle the 'removeTag' action
          // tree



          break;
        case 'textContent':
          // Handle the 'removeTag' action
          // tree
          console.log('pr' + target_element)
          const element1 = getElementById1(target_element);
          if (element1) {
            const textContentButton = element1.querySelector('[data-element="code-tree-text-content-button"]');
            textContentButton.textContent = `📄${value.length}`;
          }


          // component
          const element2 = getElementById1(removeLastOccurrence(target_element, '-tree'));
          element2.textContent = value;


          break;

        // Add more cases as needed for other actions

        case 'removeAttributeFromCopies':
          console.log('pr' + target_element);

          const selector111 = '[id^="' + removeLastOccurrence(target_element, '-tree').split(':')[0] + '"]';
          const els111 = querySelectorAll1(selector111); // Corrected the function name to document.querySelectorAll
          // component
          for (const elementToRemoveAttribute of els111) {
            if (key) { // Check if key exists
              elementToRemoveAttribute.removeAttribute(key);
              if (key === 'data-parentid') {
                querySelectorAll1('[id^="' + elementToRemoveAttribute.id + ';"]').forEach(el => {
                  el.id = el.id.replace(elementToRemoveAttribute.id + ';', '');
                });
              }
            }
          }
          break;
        case 'setAttribute':
          console.log('pr' + target_element);


          // component
          if (key === 'style' || key === 'class') {
            const selector = '[id^="' + removeLastOccurrence(target_element, '-tree').split(':')[0] + '"]';
            querySelectorAll1(selector).forEach(element => !element.id.endsWith('-fieldset') && !element.id.endsWith('-tree') && element.setAttribute(key, value))
            break;
          }

          const element22 = getElementById1(removeLastOccurrence(target_element, '-tree'));
          const element33 = getElementById1(target_element);
          if (key) {
            console.log('key11 ' + key)
            console.log('value ' + value)

            element22.setAttribute(key, value);
            if (!element22.textContent && key.toLowerCase() === 'data-visual-defaultTextNode'.toLowerCase()) {
              console.log('not found 111')
              element22.textContent = value
            }
          }
          function recursivelyChangeIDs(element, newID, flag, treeType) {
            if (!element) return; // Base case: stop if element is null
            if (treeType) {
              !flag && element.tagName.toLowerCase() === "fieldset" && (element.id = newID + ';' + element.id);
            }
            // Change ID of the current element
            else {
              !flag && (element.id = newID + ';' + element.id);
            }


            // Recursively change IDs of child elements
            Array.from(element.children).forEach(child => {
              recursivelyChangeIDs(child, newID, false, treeType);
            });
          }
          if (key === 'data-parentid') {
            recursivelyChangeIDs(element22, removeLastOccurrence(target_element, '-tree'), true);
            recursivelyChangeIDs(element33, removeLastOccurrence(target_element, '-tree'), true, true);
          }
          break;
        case 'removeAttribute':
          console.log('pr' + target_element);


          // component
          const elementToRemoveAttribute = getElementById1(removeLastOccurrence(target_element, '-tree'));
          key && elementToRemoveAttribute.removeAttribute(key);
          if (key === 'data-parentid') {
            querySelectorAll1('[id^="' + removeLastOccurrence(target_element, '-tree') + ';"]').forEach(el => {
              el.id = el.id.replace(removeLastOccurrence(target_element, '-tree') + ';', '')
            });
          }

          break;


        // Add more cases as needed for other actions

        default:
          // Handle the default case if no matching action is found
          console.error(`Unknown action: ${action}`);
          break;
      }

    }
    async function loader(e, handler) {
      const loadingScreen = getElementById1('loading');
      loadingScreen.style.display = 'flex';
      const prefixesToRemove = [
        'component-element',
        'tree-element',
        'component-replace-menu',
        'code-tree-tag-attributes-form',
        'code-tree-click-tag',
        'code-tree-add-tag-step-1',
        'code-tree-append-or-insert-approv-menu',
        'code-tree-inner-html-receive-menu',
        'tag-table',
        "code-tree-tag-text-content-form"
      ];

      prefixesToRemove.forEach(prefix => {
        const p = getElementById1("code-tree")
        const elementsToRemove = p.querySelectorAll(`fieldset[id^="${prefix}"]`);
        elementsToRemove.forEach(element => element.remove());
      });
      const timerElement = getElementById1('timer');
      let tenthsOfSeconds = 0;
      const interval = setInterval(function () {
        tenthsOfSeconds++;
        timerElement.textContent = (tenthsOfSeconds / 10).toFixed(1);
      }, 100);

      await handler(e);

      loadingScreen.style.display = 'none';
      clearInterval(interval);
      console.log(timerElement.textContent)
      const lastActionTime = getElementById1('last-action-time');

      lastActionTime.textContent = timerElement.textContent;
    }
    function openAttributeContent(event) {
      const button = event.target.closest('button[data-element="code-tree-attributes-button"]');

      if (button) {
        const parentId = button.parentNode.id;
        const generatedId = removeLastOccurrence(parentId, '-tree')
        const textContentButton = button.parentNode.querySelector('[data-element="code-tree-attributes-button]');

        const existingClonedFieldset = button.parentNode.querySelector('[id^="code-tree-tag-attributes-form-1"]');

        if (!existingClonedFieldset) {
          // Clone the fieldset node
          const fieldset = getElementById1('code-tree-tag-attributes-form-1');
          const clonedFieldset = fieldset.cloneNode(true);

          // Assign a unique id to the cloned fieldset
          clonedFieldset.id = 'code-tree-tag-attributes-form-1;' + parentId;

          // Find the position to insert the cloned fieldset
          const insertAfterElement = textContentButton || button;

          // Insert the cloned fieldset after the specified element
          insertAfterElement.parentNode.querySelector('[data-open-menu]').append(clonedFieldset)
          const elementWithAttributes = getElementById1(generatedId);
          if (elementWithAttributes) {
            const attributesList = clonedFieldset.querySelector('#code-tree-tag-attributes-list');



            // Clone the original tr element for each attribute
            const originalTr = clonedFieldset.querySelector('#code-tree-tag-attributes-list-item');
            for (const attribute of elementWithAttributes.attributes) {
              const clonedTr = originalTr.cloneNode(true);

              // Modify data based on attributes of the elementWithAttributes
              const keyElement = clonedTr.querySelector('#code-tree-tag-attribute-key');
              const valueElement = clonedTr.querySelector('#code-tree-tag-attribute-value');

              keyElement.textContent = attribute.name;
              valueElement.textContent = attribute.value;

              // Append the modified tr to the list
              attributesList.appendChild(clonedTr);
            }

            // Remove the original tr element
            originalTr.remove();

          }
        }
      }
    }
    function openTextContent(event) {
      const button = event.target.closest('button[data-element="code-tree-text-content-button"]');

      if (button) {
        const parentId = button.parentNode.id;
        const textContentButton = button.parentNode.querySelector('[data-element="code-tree-text-content-button"]');

        const existingClonedFieldset = button.parentNode.querySelector('[id^="code-tree-tag-text-content-form"]');

        if (!existingClonedFieldset) {
          // Clone the fieldset node
          const fieldset = getElementById1('code-tree-tag-text-content-form');
          const clonedFieldset = fieldset.cloneNode(true);
          clonedFieldset.querySelector('textarea').value = getElementById1(parentId.replace('-tree', '')).innerHTML
          // Assign a unique id to the cloned fieldset
          clonedFieldset.id = 'code-tree-tag-text-content-form;' + parentId;

          // Find the position to insert the cloned fieldset
          const insertAfterElement = textContentButton || button;

          // Insert the cloned fieldset after the specified element
          insertAfterElement.parentNode.querySelector('[data-open-menu]').append(clonedFieldset)
        }
      }
    }
    function openInnerHtmlContent(event) {
      const button = event.target.closest('button[data-element="code-tree-inner-html-button"]');

      if (button) {
        const parentId = button.parentNode.id;
        const textContentButton = button.parentNode.querySelector('[data-element="code-tree-inner-html-button"]');

        const existingClonedFieldset = button.parentNode.querySelector('[id^="code-tree-tag-html-content-form"]');

        if (!existingClonedFieldset) {
          // Clone the fieldset node
          const fieldset = getElementById1('code-tree-tag-html-content-form');
          const clonedFieldset = fieldset.cloneNode(true);
          clonedFieldset.querySelector('textarea').value = getElementById1(parentId.replace('-tree', '')).textContent
          // Assign a unique id to the cloned fieldset
          clonedFieldset.id = 'code-tree-tag-html-content-form;' + parentId;

          // Find the position to insert the cloned fieldset
          const insertAfterElement = textContentButton || button;

          // Insert the cloned fieldset after the specified element
          insertAfterElement.parentNode.querySelector('[data-open-menu]').append(clonedFieldset)
        }
      }
    }

    function handleComponentClick(event) {
      const button = event.target.closest('button[data-element="code-tree-tag-name-button"]');
      console.log('in111')
      if (button) {
        const parentId = button.parentNode.id;
        const textContentButton = button.parentNode.querySelector('[data-element="code-tree-text-content-button"]');

        // Check if a cloned fieldset already exists after the parent node
        const existingClonedFieldset = button.parentNode.querySelector('[id^="code-tree-click-component"]');

        if (!existingClonedFieldset) {
          // Clone the fieldset node
          const fieldset = getElementById1('code-tree-click-component');
          const clonedFieldset = fieldset.cloneNode(true);

          // Assign a unique id to the cloned fieldset
          clonedFieldset.id = 'code-tree-click-component;' + parentId;
          clonedFieldset.setAttribute('path', button.getAttribute('path'))
          clonedFieldset.setAttribute('replaced', button.parentNode.getAttribute('replaced'))
          // Find the position to insert the cloned fieldset
          const insertAfterElement = textContentButton || button;

          // Insert the cloned fieldset after the specified element
          insertAfterElement.parentNode.querySelector('[data-open-menu]').append(clonedFieldset)
        }
      }
    }
    function handleTreeClick(event) {
      const button = event.target
      console.log('tree clicked')
      if (button) {
        const parentId = button.parentNode.id;
        const textContentButton = button.parentNode.querySelector('[data-element="code-tree-text-content-button"]');

        // Check if a cloned fieldset already exists after the parent node
        const existingClonedFieldset = button.parentNode.querySelector('[id^="code-tree-click-tag;"]');

        if (!existingClonedFieldset) {
          // Clone the fieldset node
          console.log('in1')
          const fieldset = getElementById1('code-tree-click-tag');
          console.log(fieldset.innerHTML)
          const clonedFieldset = fieldset.cloneNode(true);

          // Assign a unique id to the cloned fieldset
          clonedFieldset.id = 'code-tree-click-tag;' + parentId;

          // Find the position to insert the cloned fieldset
          const insertAfterElement = textContentButton || button;

          // Insert the cloned fieldset after the specified element
          insertAfterElement.parentNode.querySelector('[data-open-menu]').append(clonedFieldset)
        }
      }
    }
    var cache = {};
    var updateComponentsMap = false

    function deepCopy(obj) {
      if (typeof obj !== 'object' || obj === null) {
        // Return the input if it's not an object
        return obj;
      }

      // Create an empty object or array to hold the copied values
      const copied = Array.isArray(obj) ? [] : {};

      // Iterate over each key in the original object
      for (let key in obj) {
        // Recursively copy nested objects or arrays
        copied[key] = deepCopy(obj[key]);
      }

      return copied;
    }
    const getRes = async (id, main, firstLoad) => {
      // Check if the response is already in the cache

      if (cache[id]) {
        return deepCopy(cache[id])
      }
      !firstLoad && (updateComponentsMap = true)

      try {
        // Make a GET request to the API with the 'id' query parameter
        const response = await fetch(`https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?id=${id}&startsWith=true`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        // Ensure the request was successful (status code 2xx)
        if (!response.ok) {
          throw new Error(`Failed to load data from the database. Status: ${response.status}`);
        }

        // Parse and log the response or handle it as needed
        const responseData = await response.json();

        // Store the response in the cache for future use
        !main && (cache[id] = responseData);

        return responseData;
      } catch (error) {
        console.error(`Error fetching data for id: ${id}`, error);
        throw error; // Re-throw the error to let the caller handle it
      }
    };
    function removeDuplicates(arr) {
      return Array.from(new Set(arr));
    }
    const setOptions = (item) => {
      const { testPage, optionalScript, LinkBP } = item
      testPage && switchTest(false)
      optionalScript && switchOptionalScript(false)
      LinkBP && switchLinkBP(false)
    }
    const loadFromDb = async (id, newId, p, timestamp, upperReplaceActions, ignore, noComp11, noSubComp, lvl, upperRemoveActions, replaceId) => {
      console.log('load from db' + id)
      console.log('err2 ' + p)
      let path = ""
      p && (path = p)
      const urlSearchParams = new URLSearchParams(window.location.search);
      let idFromLink = urlSearchParams.get('id');
      let responseData
      const showSku = async (sku) => {
        getElementById1("input-sku").setAttribute('hidden', '')
        getElementById1("create-sku").setAttribute('hidden', '')
        const item1 = getElementById1("sku-item-1")
        const cloned1 = item1.cloneNode(true)
        cloned1.removeAttribute('hidden')
        getElementById1("sku-list").removeAttribute('hidden')
        cloned1.querySelector("#sku-value").textContent = sku
        cloned1.querySelector("#remove-sku").setAttribute('hidden', '')
        const { items } = await fetch(`https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?id=${sku}&sk=qty;&startsWith=true`)
          .then(response => response.json())
        const el = cloned1.querySelectorAll('#sku-item')
        const parent = cloned1.querySelector('#sku-attribute-list')
        if (items.length > 1) {

          for (const item of items) {
            const cloned = el[0].cloneNode(true)
            cloned.querySelector('#sku-attribute-value').textContent = item.sk.replace('qty;', '')
            parent.appendChild(cloned)
          }


        }
        else {
          const cloned = el[0].cloneNode(true)
          cloned.querySelector('#sku-attribute-value').textContent = 'Solo'
          parent.appendChild(cloned)
        }
        getElementById1("sku-list").appendChild(cloned1)
        el.forEach(e => e.remove())
      }
      if (id) {

        responseData = await getRes(id)

        const { items } = responseData
        console.log('iteeems ' + JSON.stringify(items))
        //change component 
        const splited = items.find(e => e.sk === 'path').lsi1.split(';')[0].split('/')
        const name = splited[splited.length - 1]
        const { testPage, optionalScript } = items.find(e => e.sk === 'path')
        const el1 = getElementById1(newId + '-tree')

        if ((testPage && lvl > 2) || (optionalScript && localStorage.getItem('visualOn'))) {
          el1.remove()
          return
        }
        else if (testPage) {
          el1.querySelector('[data-element="code-tree-test-button"]').removeAttribute('hidden')
          el1.querySelector('[data-element="code-tree-text-content-button"]').remove()
          el1.querySelector('[data-element="code-tree-inner-html-button"]').remove()
        }

        const el = el1.querySelector("[data-element='code-tree-tag-name-button']")
        el.textContent = '🧩' + name
        el.setAttribute('path', items.find(e => e.sk === 'path').lsi1)
        //insertDataIntoCodeLog(timestamp, idFromLink, { name })
      }
      else {
        components.push(idFromLink)
        responseData = await getRes(idFromLink, true)
        const { items } = responseData
        const map = items.find(e => e.sk === 'componentsMap')
        let r;
        if (map) {
          r = Promise.all(map.items.map(id => getRes(id, false, true)))
        }
        pathItem = items.find(e => e.sk === 'path')
        const splited = pathItem.lsi1.split(';')[0].split('/')

        console.log('path item ' + JSON.stringify(pathItem))
        setOptions(pathItem)
        const name = splited[splited.length - 1]
        if (name.toLowerCase() === 'breadcrumb') {
          document.getElementById('breadCrumb-menu').removeAttribute('hidden')
        }
        const el = getElementById1(idFromLink + '-tree').querySelector("[data-element='code-tree-tag-name-button']")
        el.textContent = '🧩' + name
        el.setAttribute('path', pathItem.lsi1)
        await r;
        //insertDataIntoCodeLog('root', idFromLink, { name })
      }
      if (!idFromLink) {
        throw new Error('Missing id parameter in the URL');
      }

      // Make a GET request to the API with the 'id' query parameter

      if (!ignore) {
        const upper = upperReplaceActions ? upperReplaceActions : []
        const upper1 = upperRemoveActions ? upperRemoveActions : []
        const replaceActions = [...responseData.items.filter(el => el.action === 'Replace_Component'), ...upper]
        const removeActions = [...responseData.items.filter(el => el.action === 'removeComponent'), ...upper1]
        for (const item of responseData.items) {
          if (!id) {
            if (item.sk === 'path') {
              const el = getElementById1('page-path')

              el.textContent = item.lsi1.replace(';publish:published', '')

              if (item.lsi1.includes('publish:published')) {
                const el2 = getElementById1("path-icon")
                el2.classList.add('b-green');
                el2.classList.add('b-selected');
                const el3 = getElementById1("published-label")
                el3.removeAttribute('hidden')
                el3.setAttribute('href', item.href)
              }
            }

          }
          else if (item.sku) {
            if (lvl < 2) {
              showSku(item.sku)
            }
            else {
              getElementById1("input-sku").setAttribute('hidden', '')
              getElementById1("create-sku").setAttribute('hidden', '')
            }

          }
          if (item.action) {
            if (id) {


              const replaceWithNewId = (s) => {
                if (!replaceId || s === 'body-tree' || s === 'body' || s === 'head-tree' | s === 'head') return s
                let id = replaceId
                if (s.endsWith('-tree')) {

                  return s.replace('-tree', '') + ':' + id + '-tree'
                }
                return s + ':' + id
              }
              if (item.target_element === id + '-tree') {

                item.target_element = newId + '-tree'
                if (item.inserted_element?.id) {
                  item.inserted_element.id.split(':').length === 1 && (item.inserted_element.id = replaceWithNewId(item.inserted_element.id, newId))
                }
                item.inserted_element?.originalId && item.inserted_element?.originalId.split(':').length === 1 && (item.inserted_element.originalId = replaceWithNewId(item.inserted_element.originalId, newId))
              }
              else if (components.includes(removeLastOccurrence(item.target_element, '-tree'))) {

              }
              else if (Array.isArray(item.target_element)) {
                console.log('array of targter '+ JSON.stringify(item.target_element))
                item.target_element = item.target_element.filter(e=>e).map(i => {
                  console.log('prob666'+ JSON.stringify(i))
                  if (i.id === id + '-tree') {
                    return { ...i, id: newId + '-tree' }
                  }
                  if (i.id.split(':').length === 1) {
                    return { ...i, id: replaceWithNewId(i.id, newId) }
                  }
                  return { ...i, id: i.id }
                })

              }
              else {

                item.target_element.split(':').length === 1 && (item.target_element = replaceWithNewId(item.target_element, newId))
                item.inserted_element?.id && item.inserted_element?.id.split(':').length === 1 && (item.inserted_element.id = replaceWithNewId(item.inserted_element.id, newId))
                item.inserted_element?.originalId && item.inserted_element?.originalId.split(':').length === 1 && (item.inserted_element.originalId = replaceWithNewId(item.inserted_element.originalId, newId))



              }

              //insertDataIntoCodeLog(item.sk, item.action)
              await executeCommand({ ...item, time: item.sk }, undefined, false, replaceActions, newId, noComp11, noSubComp, lvl, removeActions, replaceId)

              continue
            }


            await pushAction({ ...item, time: item.sk }, true, false, replaceActions, newId, noComp11, noSubComp, lvl, removeActions, replaceId)
          }

        }
      }
      else {

      }


    }
    function traverseJSONAndUpdate(json, path = '', sender = '') {
      // Iterate through each key-value pair in the JSON object
      for (const key in json) {
        if (json.hasOwnProperty(key)) {
          // Construct the full path for the current key
          const currentPath = path ? `${path}.${key}` : key;
          // If the current value is an array, handle each element individually
          if (Array.isArray(json[key])) {
            // Find the data-transfer-cloner attribute for the current array
            const clonerAttributes = querySelectorAll1(`[data-transfer-cloner="${sender}.${currentPath}"]`);
            if (clonerAttributes.length > 0) {
              const arrayOfObjects = [];
              // Iterate through each set of cloned elements
              clonerAttributes.forEach(clonerAttribute => {
                if (typeof json[key][0] === 'string') {
                  if (clonerAttribute.hasAttribute('data-transfer-sender')) {
                    arrayOfObjects.push(clonerAttribute.textContent);
                  }
                  else if (clonerAttribute.hasAttribute('data-transfer-sender-href')) {
                    arrayOfObjects.push(clonerAttribute.getAttribute('href'));
                  }
                  else if (clonerAttribute.hasAttribute('data-transfer-sender-href')) {
                    arrayOfObjects.push(clonerAttribute.getAttribute('src'));
                  }

                }
                else {
                  const objectFromClonedElements = { ...json[key][0] };
                  // Iterate through each cloned element within the current set
                  if (clonerAttribute.hasAttribute('data-transfer-sender')) {
                    const attributeKey = clonerAttribute.getAttribute('data-transfer-sender').split('.').pop();
                    if (objectFromClonedElements[attributeKey] === null) {
                      objectFromClonedElements[attributeKey] = parseInt(clonerAttribute.textContent);
                    }
                    else {
                      objectFromClonedElements[attributeKey] = clonerAttribute.textContent;
                    }

                  }
                  else if (clonerAttribute.hasAttribute('data-transfer-sender-href')) {
                    const attributeKey = clonerAttribute.getAttribute('data-transfer-sender-href').split('.').pop();

                    objectFromClonedElements[attributeKey] = clonerAttribute.getAttribute('href');
                  }
                  else if (clonerAttribute.hasAttribute('data-transfer-sender-href')) {
                    const attributeKey = clonerAttribute.getAttribute('data-transfer-sender-src').split('.').pop();

                    objectFromClonedElements[attributeKey] = clonerAttribute.getAttribute('src');
                  }
                  else {
                    clonerAttribute.querySelectorAll('[data-transfer-sender]').forEach(element => {
                      const attributeKey = element.getAttribute('data-transfer-sender').split('.').pop();
                      if (objectFromClonedElements[attributeKey] === null) {
                        objectFromClonedElements[attributeKey] = parseInt(clonerAttribute.textContent);
                      }
                      else {
                        objectFromClonedElements[attributeKey] = clonerAttribute.textContent;
                      }
                    });
                    clonerAttribute.querySelectorAll('[data-transfer-sender-href]').forEach(element => {
                      const attributeKey = element.getAttribute('data-transfer-sender-href').split('.').pop();
                      objectFromClonedElements[attributeKey] = clonerAttribute.getAttribute('href');
                    });
                    clonerAttribute.querySelectorAll('[data-transfer-sender-src]').forEach(element => {
                      const attributeKey = element.getAttribute('data-transfer-sender-src').split('.').pop();
                      objectFromClonedElements[attributeKey] = clonerAttribute.getAttribute('src');
                    });
                  }
                  // Push the created object to the array of objects
                  arrayOfObjects.push(objectFromClonedElements);
                }



              });
              // Update the value of the array in the JSON object
              json[key] = arrayOfObjects;
            }
          }

          // If the current value is an object or an array, recursively traverse it
          else if (typeof json[key] === 'object' && json[key] !== null) {
            traverseJSONAndUpdate(json[key], currentPath, sender);
          } else {
            // If the current value is a string, check for the data-transfer-sender attribute
            const senderPath = sender ? `${sender}.${currentPath}` : currentPath;
            let senderAttribute = querySelectorAll1(`[data-transfer-sender="${senderPath}"]`);


            if (senderAttribute.length) {
              if (json[key] === null) {
                json[key] = parseInt(senderAttribute[0].textContent) || null;
              }
              else {
                json[key] = senderAttribute[0].textContent || "";
              }

            }
            else {
              let senderAttribute = querySelectorAll1(`[data-transfer-sender-href="${senderPath}"]`);
              console.log('iiin2')
              if (senderAttribute.length) {

                json[key] = senderAttribute[0].getAttribute('href') || "";


              } else {
                let senderAttribute = querySelectorAll1(`[data-transfer-sender-src="${senderPath}"]`);
                console.log('iiin3')
                if (senderAttribute.length) {

                  json[key] = senderAttribute[0].getAttribute('src') || "";


                }
              }

            }



          }



        }
      }
    }
    function removeEmptyValues(obj) {
      for (let prop in obj) {
        if (obj[prop] === "" || obj[prop] === null) {
          delete obj[prop];
        } else if (typeof obj[prop] === "object") {
          removeEmptyValues(obj[prop]); // Recursively call removeEmptyValues for nested objects
          if (Object.keys(obj[prop]).length === 0) {
            delete obj[prop]; // Delete the key if the nested object becomes empty after removing empty values
          }
        }
      }
      return obj;
    }
    function removeSingleAtKey(obj) {
      for (let prop in obj) {
        if (typeof obj[prop] === "object") {
          removeSingleAtKey(obj[prop]); // Recursively call removeSingleAtKey for nested objects
          if (Object.keys(obj[prop]).length === 1 && Object.keys(obj[prop])[0].startsWith("@")) {
            delete obj[prop]; // Delete the attribute if it has only one key starting with "@"
          }
        }
      }
      return obj;
    }
    const cleanJson = (json) => {
      let newJson = removeEmptyValues(json)
      newJson = removeSingleAtKey(json)
      return newJson
    }
    const generateSchema = () => {
      const generatedPage = getElementById1('generated-page')
      const schemas = querySelectorAll1('script[data-transfer-receiver]')
      for (const schema of schemas) {
        const receiverName = schema.getAttribute('data-transfer-receiver')
        let json = JSON.parse(schema.textContent)
        // Start traversing the JSON object
        traverseJSONAndUpdate(json, '', receiverName);

        json = cleanJson(json)
        // After updating, stringify the JSON object and assign it back to the text content of the schema element
        schema.textContent = JSON.stringify(json, null, 2);
        console.log('OUTPUT SCHEMA JSON ' + JSON.stringify(json))
      }
      const tags = querySelectorAll1('[data-transfer-receiver]')
      for (const tag of tags) {
        if (tag.tagName.toLowerCase() !== 'script') {
          const receiver = tag.getAttribute('data-transfer-receiver');
          const link = pathItem.lsi1.replace(';publish:published', '').toLowerCase()
          if (receiver === "canonical" && link.endsWith('/hub')) {
            const splited = link.split('/')
            splited.pop()
            if (splited[splited.length - 1] === 'home') {
              splited.pop()
            }
            let nLink = splited[0]
            if (splited.length > 1) {
              nLink = splited.join('/') + '/'
            }

            tag.setAttribute('href', "https://" + nLink)

          }
          const senders = querySelectorAll1(`[data-transfer-sender^="${receiver}."]`);
          const senders2 = querySelectorAll1(`[data-transfer-sender-href^="${receiver}."]`);
          const senders3 = querySelectorAll1(`[data-transfer-sender-src^="${receiver}."]`);
          if (senders.length) {
            for (const sender of senders) {
              const textContent = sender.textContent;
              const attr = sender.getAttribute('data-transfer-sender').replace(receiver + '.', '');
              if (attr === 'text-content') {
                tag.textContent = textContent
              } else {
                tag.setAttribute(attr, textContent);
              }

            }

          }
          if (senders2.length) {
            for (const sender of senders2) {
              const textContent = sender.getAttribute("href");
              console.log('sender2')
              const attr = sender.getAttribute('data-transfer-sender-href').replace(receiver + '.', '');
              if (attr === 'text-content') {
                tag.textContent = textContent
              } else {
                tag.setAttribute(attr, textContent);
              }

            }

          }
          if (senders3.length) {
            for (const sender of senders3) {
              const textContent = sender.getAttribute('src');
              const attr = sender.getAttribute('data-transfer-sender-src').replace(receiver + '.', '');
              if (sender.hasAttribute('data-builder-image-name')) {
                console.log('iiin55555')
                const name = sender.getAttribute('data-builder-image-name')
                const e = 'https://' + link.toLowerCase() + '/' + name + '.' + textContent.split('.').pop()
                tag.setAttribute(attr, e);
                continue
              }
              if (attr === 'text-content') {
                tag.textContent = textContent
              } else {
                tag.setAttribute(attr, textContent);
              }

            }

          }
        }

      }
    }
    var handleItemLink = async () => {
      const currentPath = pathItem.lsi1.replace(';publish:published', '').toLowerCase()
      if ((currentPath.endsWith("/article") || currentPath.endsWith("/product")) &&
        (currentPath.includes("/products/") || currentPath.includes("/blog/")) &&
        !currentPath.includes("/seed-article/") &&
        !currentPath.includes("/settings-article/") &&
        !currentPath.includes("/seed-product/") &&
        !currentPath.includes("/settings/") &&
        !currentPath.includes("/setting-product/")) {

        const splited = currentPath.split('/')
        splited.pop()
        const href = 'https://' + splited.join('/') + '/'
        const item = querySelectorAll1('[data-builder-item-link]')[0]
        if (item.getAttribute('href') !== href) {
          const el = {
            time: (new Date()).getTime(),
            action: 'setAttribute',
            target_element: item.id + '-tree',
            key: 'href',
            value: href,

          }
          await pushAction(el)
        }
      }
    }
    const publish = async (e) => {
      const el2 = getElementById1("path-icon")
      el2.classList.remove('b-green');
      el2.classList.remove('b-selected');
      const el3 = getElementById1("published-label")
      el3.setAttribute('hidden', '')
      //to remove list
      const toRemove = {
        attributesStartWith: ["data-remove"],
        attributesEqual: ["data-remove"],
        removeAttributesStartWith: ["data-visual", "data-builder", "data-transfer"]
      }

      const robotsTxt = `
      User-agent: *
      Disallow: /cart/
      `;
      const siteMapPriority = {

        '/products/': 0.9,
        '/blog/': 0.8,
        '/': 1,

      };
      const siteMapNotDefiniedPriorities = 0.5;

      /*
  
      if ((currentPath.endsWith("/article") || currentPath.endsWith("/product")) &&
      (currentPath.includes("/products/") || currentPath.includes("/blog/")) &&
      !currentPath.includes("/seed-article/") &&
      !currentPath.includes("/settings-article/") &&
      !currentPath.includes("/seed-product/") &&
      !currentPath.includes("/settings/") &&
      !currentPath.includes("/setting-product/")) {
      
      console.log("Conditions ok, set data-builder-item-link .");
  
      */


      /*
  
      if ((currentPath.endsWith("/breadcrumb") &&
      !currentPath.includes("/seed-") &&
      !currentPath.includes("/settings-") &&
      !currentPath.includes("/settings/") &&
      !currentPath.includes("/setting-product/")) {
    
      console.log("Conditions ok, generate breadcrumb .");
  
      
      */




      const pagePathContent = getElementById1('page-path').textContent;

      // Use the textContent as needed, for example, log it to the console
      console.log('Publishing:', pagePathContent);
      const urlSearchParams = new URLSearchParams(window.location.search);
      let idFromLink = urlSearchParams.get('id');
      generateSchema()
      const html = getElementById1('generated-page').innerHTML
      const response = await fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2/publishv2', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ id: idFromLink, html, path: pagePathContent, toRemove, robotsTxt, siteMapPriority, siteMapNotDefiniedPriorities }),
      });
      const r = await response.json()
      console.log('link: ' + r.link)
      const el = getElementById1('page-path')



      getElementById1('page-path').textContent = pagePathContent

      el2.classList.add('b-green');
      el2.classList.add('b-selected');
      el3.removeAttribute('hidden')
      el3.setAttribute('href', r.link)


    }
    const handleSelectedDependeeChange = async (e) => {
      const resultList = await getProductAttributes()
      const checked1 = getChecked(resultList)
      const dependeeItems = querySelectorAll1(`[data-builder-dependee]`)
      for (const item of dependeeItems) {
        const attr = item.getAttribute('data-product-info')
        if (!attr) {
          continue
        }
        const splited = attr.split(';')
        splited.shift()
        const f = splited.find(el => !checked1.includes(el))
        if (f) {
          item.style.display = 'none'
        }
        else {
          item.style.display = 'block'
        }
      }
    }
    const handleDependency = async () => {
      const items = querySelectorAll1('[data-product-info]')
      if (items) {
        const resultList = await getProductAttributes()
        for (const element of resultList) {
          const form = element.form
          if (form && form.children) {
            // Iterate through the child elements of the form
            for (const child of form.children) {
              // Check if the child element is a label
              if (child.tagName === 'LABEL') {
                // Find the input within the label
                const input = child.querySelector('input[type="radio"]');

                // Add change event listener if input exists
                if (input) {
                  input.addEventListener('change', handleSelectedDependeeChange);
                }
              }
            }
          }

        }
      }
    }
    document.addEventListener('DOMContentLoaded', loadFirst);

    async function loadFirst() {
      var iframe = getElementById1("generated-page-iframe");

      // Wait for the iframe to load completely
      await new Promise(resolve => {
        iframe.addEventListener("load", resolve);

      });
      var iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
      const lastActionTime = getElementById1('last-action-time');
      lastActionTime.addEventListener('dblclick', function () {
        // Handle double-click event here
        console.log('Double-clicked on the button');
        // Add your custom logic for double-click handling
      });
      const loadingScreen = getElementById1('loading');
      loadingScreen.style.display = 'flex';
      const timerElement = getElementById1('timer');
      let tenthsOfSeconds = 0;
      const interval = setInterval(function () {
        tenthsOfSeconds++;
        timerElement.textContent = (tenthsOfSeconds / 10).toFixed(1);
      }, 100);
      const urlParams = new URLSearchParams(window.location.search);
      const idFromQuery = urlParams.get('id');

      if (idFromQuery) {
        // Change the id of the element with id "component-element"
        const compTree = getElementById1('components-tree')
        const component_el = getElementById1('component-element')
        const newEl2 = component_el.cloneNode(true)
        newEl2.id = idFromQuery + '-tree'
        compTree.append(newEl2)

        const builderElement = getElementById1('63ae5927-390f-4391-993d-b25ab09c8ada');
        if (builderElement) {
          builderElement.id = idFromQuery;
        }

        // Change the text content of the button with data-element "code-tree-tag-name-button"
        const componentNameButton = document.querySelector('[data-element="code-tree-tag-name-button"]');
        if (componentNameButton) {
          componentNameButton.innerText = `🧩${idFromQuery}`;
        }
      }
      await loadFromDb()
      if (updateComponentsMap) {
        const componentsIds = Object.keys(cache)
        const response1 = await fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ id: idFromQuery, sk: 'componentsMap', items: componentsIds }),
        });

      }
      await handleHead()
      await handleSelectedDependeeChange()
      await handleDependency()


      await handleItemLink()
      //first menu
      let buttons = querySelectorAll1('button[data-element="code-tree-tag-name-button"]');
      /*
      buttons.forEach(function (button) {
        button.addEventListener('click', e => loader(e, handleComponentClick));
      });*/
      clearInterval(interval);
      console.log(timerElement.textContent)
      if (localStorage.getItem('visualOn')) {

        getElementById1('transform').click()
      }
      lastActionTime.textContent = timerElement.textContent;
      loadingScreen.style.display = 'none';

    }
    function generateCombinations(data) {
      const combinations = [];

      data.forEach(item => {
        item.items.forEach(attribute => {
          const combination = {
            legend: item.legend,
            attribute: attribute
          };
          combinations.push(combination);
        });
      });

      const result = [];
      const combine = (arr, idx, current) => {
        if (idx === arr.length) {
          result.push(current);
          return;
        }
        arr[idx].items.forEach(item => {
          combine(arr, idx + 1, current + `${arr[idx].legend}:${item};`);
        });
      };

      combine(data, 0, '');

      return result;
    }
    const openRemoveSku = (event) => {
      const menu = event.target.parentNode.querySelector('#remove-sku-menu')
      menu.style.display = 'block'
    }
    const removeSku = async (event) => {

      const sku = event.target.parentNode.parentNode.querySelector('#sku-value').textContent
      pathItem.sku = undefined
      await fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(pathItem),
      });
      const { items } = await fetch(`https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?id=${sku}&sk=qty;&startsWith=true`)
        .then(response => response.json())
      const res = await Promise.all(items.map(async item => {
        const deleteUrl = `https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2/${item.id}:${item.sk}`;
        const response = await fetch(deleteUrl, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
            // Add any additional headers if needed
          },

        });
      }))
      //to complete
      event.target.parentNode.parentNode.remove()
      getElementById1("input-sku").removeAttribute('hidden')
      getElementById1("create-sku").removeAttribute('hidden')
    }
    const addSku = async (event) => {
      const value = getElementById1('input-sku').value

      const { items } = await fetch(`https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?id=${value}&sk=qty;&startsWith=true`)
        .then(response => response.json())
      if (items.length) {
        getElementById1('input-sku').value = ''
        return
      }
      const resultList = await getProductAttributes(true)
      const combinations = generateCombinations(resultList)
      pathItem.sku = value
      //update path item
      await fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(pathItem),
      });
      //create sku
      for (const combination of combinations) {
        const item = {
          id: value,
          sk: 'qty;' + combination
        }
        const existing = await fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2/' + value + ':' + item.sk)
          .then(response => response.json())
        if (!existing) {
          await fetch('https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(item),
          });
        }
      }
      if (combinations.length === 1) {
        querySelectorAll1('[data-builder-schema="aggregate-product"]').forEach(element => {
          const el =
          {
            time: (new Date()).getTime(),
            action: 'removeTag',
            target_element: element.id + '-tree',

          }
          pushAction(el)
        })
      }
      else {
        querySelectorAll1('[data-builder-schema="single-product"]').forEach(element => {
          const el =
          {
            time: (new Date()).getTime(),
            action: 'removeTag',
            target_element: element.id + '-tree',

          }
          pushAction(el)
        })
      }
      showSku(value, true)
      setDataProduct(value, resultList)
    }
    const setDataProduct = async (sku, items) => {
      const dataProductEls = querySelectorAll1('[data-product=""]')
      const splited = pathItem.lsi1.split(';')[0].split('/')
      const name = splited[splited.length - 1]
      dataProductEls.forEach(async dataProductEl => {
        const el = {
          time: (new Date()).getTime(),
          action: 'setAttribute',
          target_element: dataProductEl.id + '-tree',
          key: 'data-product',
          value: `${sku}`,

        }
        await pushAction(el)
      })
      console.log(JSON.stringify(items))
      if (items.length > 1 || items[0]?.items.length > 1) {

        for (const item of items) {
          const form = item.form
          var labels = form.querySelectorAll('label[data-product-attribute]');
          const defaultCheckbox = form.querySelector('input[type="radio"]')
          // Loop through each label
          for (let i = 0; i < labels.length; i++) {
            const label = labels[i]
            // Find the corresponding input element
            const compositeId = item.legend + '-' + label.textContent
            //duplicate checkbox and insert before label
            const actionObject = {
              time: (new Date()).getTime(),
              action: 'InsertBefore',
              target_element: label.id + '-tree',
              inserted_element: { originalId: defaultCheckbox.id + '-tree', id: compositeId + '-tree' },
            };
            //await pushAction(actionObject);



            //set for in label
            const el = {
              time: (new Date()).getTime(),
              action: 'setAttribute',
              target_element: label.id + '-tree',
              key: 'for',
              value: compositeId,

            }
            //await pushAction(el)
            //set for in label
            const input = label.querySelector('input[type="radio"]')
            const el1 = {
              time: (new Date()).getTime(),
              action: 'setAttribute',
              target_element: input.id + '-tree',
              key: 'name',
              value: sku + ';' + item.legend,

            }
            await pushAction(el1)

            if (i === 0) {
              const el = {
                time: (new Date()).getTime(),
                action: 'setAttribute',
                target_element: input.id + '-tree',
                key: 'checked',
                value: 'true',

              }
              await pushAction(el)
            }

          };
          const el =
          {
            time: (new Date()).getTime(),
            action: 'removeTag',
            target_element: defaultCheckbox.id + '-tree',

          }
          //await pushAction(el)
        }

      }
      else {
        const element = items[0].form
        const el =
        {
          time: (new Date()).getTime(),
          action: 'removeTag',
          target_element: element.id + '-tree',

        }
        await pushAction(el)
      }
    }
    const getProductAttributes = async (setNumbers) => {
      const resultList = [];
      const forms = querySelectorAll1('[data-product-attribute-form]');

      for (let i = 0; i < forms.length; i++) {
        const form = forms[i]
        if (setNumbers) {
          const el = {
            time: (new Date()).getTime(),
            action: 'setAttribute',
            target_element: forms[i].id + '-tree',
            key: 'data-product-attribute-form',
            value: i + 1,

          }
          await pushAction(el)
        }
        const legendElement = form.querySelector('[data-product-attribute-legend]');
        const legend = legendElement && legendElement.textContent;

        const attributeElements = form.querySelectorAll('[data-product-attribute]');
        const attributes = Array.from(attributeElements).map(element => element.textContent);

        resultList.push({
          form,
          legend: legend,
          items: attributes
        });
      };
      return resultList
    }

    const showSku = async (sku) => {

      const item1 = getElementById1("sku-item-1")
      getElementById1("input-sku").setAttribute('hidden', '')
      getElementById1("create-sku").setAttribute('hidden', '')
      const cloned1 = item1.cloneNode(true)
      cloned1.removeAttribute('hidden')
      getElementById1("sku-list").removeAttribute('hidden')
      cloned1.querySelector("#sku-value").textContent = sku
      cloned1.querySelector("#remove-sku").removeAttribute('hidden')
      const { items } = await fetch(`https://5jfh1fonoh.execute-api.us-east-1.amazonaws.com/prod/templatesv2?id=${sku}&sk=qty;&startsWith=true`)
        .then(response => response.json())
      const el = cloned1.querySelectorAll('#sku-item')
      const parent = cloned1.querySelector('#sku-attribute-list')
      if (items.length > 1) {

        for (const item of items) {
          const cloned = el[0].cloneNode(true)
          cloned.querySelector('#sku-attribute-value').textContent = item.sk.replace('qty;', '')
          parent.appendChild(cloned)
        }


      }
      else {
        console.log('showing sku')
        const cloned = el[0].cloneNode(true)
        cloned.querySelector('#sku-attribute-value').textContent = 'Solo'
        parent.appendChild(cloned)
      }
      getElementById1("sku-list").appendChild(cloned1)
      el.forEach(e => e.remove())
    }
    const handleHead = async () => {

      const resultList = await getProductAttributes()

      if (resultList.length || pathItem.sku) {
        getElementById1('sku-menu').removeAttribute('hidden')

        pathItem.sku && showSku(pathItem.sku, true)



      }
      const splited = pathItem.lsi1.split(';')[0].split('/')
      const name = splited[splited.length - 1]
      /*
      querySelectorAll1('[data-product]').forEach(
        element => {
          const prev = element.getAttribute('data-product')
          if (prev) {
            const [first, last] = prev.split(';')
            element.setAttribute('data-product', [first, name].join(';'))
          }
        }
      )
      */


    }
    const save = async (event) => {
      const parent = event.target.parentNode
      const { id } = parent
      const action = parent.getAttribute('action')
      console.log('ac' + action)
      if (action === 'innerHtml') {
        const saveButton = event.target;
        const fieldset = saveButton.closest('fieldset');

        console.log(id)
        const textareaValue = fieldset.querySelector('#code-tree-inner-html-receive-textarea').value;

        const splited = id.split(';')
        const [toRemove, ...rest] = splited
        const el = {
          time: (new Date()).getTime(),
          action,
          target_element: rest.join(';'),
          insertedCode: textareaValue,

        }
        console.log(JSON.stringify(el))
        await pushAction(el)
      }
      parent.remove()
      console.log(JSON.stringify(actionLog))

    }
    const saveText = async (event) => {
      const parent = event.target.parentNode
      const { id } = parent
      const action = 'textContent'
      console.log('ac' + action)

      const saveButton = event.target;
      const fieldset = saveButton.closest('fieldset');


      const textareaValue = fieldset.querySelector('#code-tree-tag-text-content').value;
      const splited = id.split(';')
      const [toRemove, ...rest] = splited

      const el = {
        time: (new Date()).getTime(),
        action,
        target_element: rest.join(';'),
        value: textareaValue,

      }
      console.log(JSON.stringify(el))
      await pushAction(el)

      parent.remove()
      console.log(JSON.stringify(actionLog))

    }
    const saveInnerHtml = async (event) => {
      const parent = event.target.parentNode
      const { id } = parent
      const action = 'innerHtml'
      console.log('ac' + action)

      const saveButton = event.target;
      const fieldset = saveButton.closest('fieldset');


      const textareaValue = fieldset.querySelector('#code-tree-tag-html-content').value;
      const splited = id.split(';')
      const [toRemove, ...rest] = splited

      const el = {
        time: (new Date()).getTime(),
        action,
        target_element: rest.join(';'),
        insertedCode: textareaValue,

      }
      console.log(JSON.stringify(el))
      await pushAction(el)

      parent.remove()
      console.log(JSON.stringify(actionLog))

    }
    const saveAttribute = async (event) => {
      const parentMenu = event.target.closest('.menu-1');

      if (!parentMenu) {
        console.error('Could not find parent menu element');
        return;
      }

      const { id } = parentMenu
      const action = 'setAttribute'
      console.log('ac' + action)

      const saveButton = event.target;
      const fieldset = saveButton.closest('fieldset');


      //const textareaValue = fieldset.querySelector('#code-tree-tag-attribute-input-key').value;
      //const textareaValue2 = fieldset.querySelector('#code-tree-tag-attribute-input-key-value').value;
      const text = fieldset.querySelector('#code-tree-tag-attribute-input-text').value;
      const splited = id.split(';')
      const [toRemove, ...rest] = splited
      function parseText(text) {
        const lines = text.split('\n');
        const result = [];

        lines.forEach(line => {
          if (line === "") {
            return
          }
          const keyValue = line.replaceAll('"', '').split('=');
          if (keyValue.length >= 2) {
            const key = keyValue[0].trim();
            keyValue.shift()
            const value = keyValue.join('=').trim();
            result.push({ key, value })
          }
          else {
            result.push({ key: line.trim(), value: "" })
          }
        });

        return result;
      }
      const list = parseText(text)
      for (const element of list) {

        const el = {
          time: (new Date()).getTime(),
          action,
          target_element: rest.join(';'),
          key: element.key,
          value: element.value,

        }
        await pushAction(el)

      }
      fieldset.querySelector('#code-tree-tag-attribute-input-text').value = ""
      //fieldset.querySelector('#code-tree-tag-attribute-input-key').value = ''
      //fieldset.querySelector('#code-tree-tag-attribute-input-key-value').value = ''
      //console.log(JSON.stringify(el))

      parentMenu.remove()
      console.log(JSON.stringify(actionLog))

    }

  </script>
  <script>

    //second menu 
    const cancelReplace = (event) => {

      event.target.parentNode.nextElementSibling.remove()
      event.target.parentNode.remove()
    }
    const cancel = (e) => {

      e.target.parentNode.remove()
    }
    const cancel1 = (e) => {

      // Assuming e is an event object
      const elementToRemove = e.target.closest('[id^="code-tree-tag-attributes-form-1;"]');

      if (elementToRemove) {
        elementToRemove.remove();
      }
    }
    var append = (e) => {
      const splited = e.target.parentNode.id.split(';')
      const [toRemove, ...rest] = splited
      const parentId = rest.join(';');
      const fieldset = getElementById1('code-tree-add-tag-step-1');

      if (!e.target.parentNode.nextElementSibling || !e.target.parentNode.nextElementSibling.id.startsWith('code-tree-add-tag-step-1')) {
        const clonedFieldset = fieldset.cloneNode(true);

        clonedFieldset.id = clonedFieldset.id + ';' + parentId;
        clonedFieldset.setAttribute('action', 'Append')
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset);
        e.target.parentNode.remove()
      }
    }

    const insertB = (e) => {


      const splited = e.target.parentNode.id.split(';')
      const [toRemove, ...rest] = splited
      const parentId = rest.join(';');
      const fieldset = getElementById1('code-tree-add-tag-step-1');

      if (!e.target.parentNode.nextElementSibling || !e.target.parentNode.nextElementSibling.id.startsWith('code-tree-add-tag-step-1')) {
        const clonedFieldset = fieldset.cloneNode(true);

        clonedFieldset.id = clonedFieldset.id + ';' + parentId;
        clonedFieldset.setAttribute('action', 'InsertBefore')
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset);
        e.target.parentNode.remove()
      }

    }
    const insertHtml = (e) => {

      const splited = e.target.parentNode.id.split(';')
      const [toRemove, ...rest] = splited
      const parentId = rest.join(';');
      const fieldset = getElementById1('code-tree-inner-html-receive-menu');

      if (!e.target.parentNode.nextElementSibling || !e.target.parentNode.nextElementSibling.id.startsWith('code-tree-inner-html-receive-menu')) {
        const clonedFieldset = fieldset.cloneNode(true);
        clonedFieldset.querySelector('textarea').value = getElementById1(parentId.replace('-tree', '')).innerHTML
        clonedFieldset.id = clonedFieldset.id + ';' + parentId;
        clonedFieldset.setAttribute('action', 'innerHtml')
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset);
        e.target.parentNode.remove()
      }
    }
    const changeTag = (e) => {
      const splited = e.target.parentNode.id.split(';')
      const [toRemove, ...rest] = splited
      const parentId = rest.join(';');
      const fieldset = getElementById1('tag-table');

      if (!e.target.parentNode.nextElementSibling || !e.target.parentNode.nextElementSibling.id.startsWith('tag-table')) {
        const clonedFieldset = fieldset.cloneNode(true);


        const clonedRows = clonedFieldset.getElementsByTagName('tbody')[0].getElementsByTagName('tr');
        for (let i = 0; i < clonedRows.length; i++) {
          const index = i; // Capture the current value of 'i' in a closure
          clonedRows[i].onclick = function (event) {
            chooseTag(index, event);
          };
        }
        clonedFieldset.id = clonedFieldset.id + ';' + parentId;
        clonedFieldset.setAttribute('action', 'ChangeTag')
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset);
        e.target.parentNode.remove()
      }
    }
    const changeTagForCopies = (e) => {
      const splited = e.target.parentNode.id.split(';')
      const [toRemove, ...rest] = splited
      const parentId = rest.join(';');
      const fieldset = getElementById1('tag-table');

      if (!e.target.parentNode.nextElementSibling || !e.target.parentNode.nextElementSibling.id.startsWith('tag-table')) {
        const clonedFieldset = fieldset.cloneNode(true);


        const clonedRows = clonedFieldset.getElementsByTagName('tbody')[0].getElementsByTagName('tr');
        for (let i = 0; i < clonedRows.length; i++) {
          const index = i; // Capture the current value of 'i' in a closure
          clonedRows[i].onclick = function (event) {
            chooseTag(index, event);
          };
        }
        clonedFieldset.id = clonedFieldset.id + ';' + parentId;
        clonedFieldset.setAttribute('action', 'ChangeTagForCopies')
        e.target.parentNode.insertAdjacentElement('afterend', clonedFieldset);
        e.target.parentNode.remove()
      }
    }
    const duplicateTag = (e) => {
      const splited = e.target.parentNode.id.split(';');
      const [toRemove, ...rest] = splited;
      const parentId = rest.join(';');
      function duplicateId(originalId,) {
        const splited = originalId.split(';');
        const lastId = splited[splited.length - 1]
        let newLastUUID
        const splited2 = lastId.split(':')
        newLastUUID = splited2[0] + ':' + generateUUID()
        splited.pop()
        return [...splited, newLastUUID].join(';') + '-tree'

      }

      const el = {
        time: (new Date()).getTime(),
        action: 'InsertBefore',
        target_element: parentId,
        inserted_element: { originalId: parentId, id: duplicateId(removeLastOccurrence(parentId, '-tree')) },
      };

      pushAction(el);
    };
    const removeTag = (e) => {
      const splited = e.target.parentNode.id.split(';')
      const [toRemove, ...rest] = splited
      const parentId = rest.join(';');
      const el =
      {
        time: (new Date()).getTime(),
        action: 'removeTag',
        target_element: parentId,

      }
      pushAction(el)
      e.target.parentNode.remove()
    }
    const removeTagAndCopies = (e) => {
      const splited = e.target.parentNode.id.split(';')
      const [toRemove, ...rest] = splited
      const parentId = rest.join(';');
      const el =
      {
        time: (new Date()).getTime(),
        action: 'removeTagAndCopies',
        target_element: parentId,

      }
      pushAction(el)
      e.target.parentNode.remove()
    }
    const removeComponent = async (e) => {
      const splited = e.target.parentNode.id.split(';')
      const [toRemove, ...rest] = splited
      const parentId = rest.join(';');
      const el =
      {
        time: (new Date()).getTime(),
        action: 'removeComponent',
        target_element: parentId,

      }
      await pushAction(el)
      location.reload()


    }
    const approve = async (event) => {
      var checkbox = event.target;

      // Get the parent fieldset
      var fieldset = checkbox.closest('fieldset');

      // Get the "Duplicate with Parent" checkbox
      var duplicateCheckbox = fieldset.querySelector('#code-tree-menu-dublicate-with-parent-option');

      // Check if the "Duplicate with Parent" checkbox is checked
      var isDuplicateWithParent = duplicateCheckbox.checked;
      // Get the id and action attributes
      var fieldsetId = fieldset.id;
      var fieldsetAction = fieldset.getAttribute('action');

      // Get all fieldsets with data-element="code-tree-tag"
      var codeTreeTagFieldsets = querySelectorAll1('fieldset[data-element="code-tree-tag"]');

      // Iterate through each fieldset and hide them
      codeTreeTagFieldsets.forEach(function (fieldset) {
        var checkbox = fieldset.querySelector('input[type="checkbox"]');
        if (checkbox) {
          checkbox.setAttribute('hidden', 'true');
        }
      });

      // Remove the parent fieldset
      fieldset.remove();

      // Log the id and action attributes (you can replace this with your desired logic)
      console.log("Fieldset ID:", fieldsetId);
      console.log("Fieldset Action:", fieldsetAction);
      const splited = fieldsetId.split(';')
      splited.shift()
      const id = splited.join(';')
      let el2 = {
        time: (new Date()).getTime(),
        action: fieldsetAction,
        target_element: [{ type: 'tag', id, }, ...selected.map(id => {
          return { type: 'tag', id }
        })],
      }
      if (isDuplicateWithParent) {
        pushAction({
          time: (new Date()).getTime(),
          action: fieldsetAction,
          withParent: true,
          target_element: [{ type: 'tag', id, }, ...selected.map(id => {
            return { type: 'tag', id }
          })],
        })


      }
      else {
        pushAction(el2)
      }
      selected = []
      event.target.parentNode.remove()
    }

  </script>

  <script>          const tags =
      [
        {
          "tagName": "head",
          "tagValue": "<head></head>",
          "TagComment": "Contains metadata/information for the document",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "title",
          "tagValue": "<title></title>",
          "TagComment": "Defines a title for the document",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "body",
          "tagValue": "<body></body>",
          "TagComment": "Defines the document's body",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "h1",
          "tagValue": "<h1></h1>",
          "TagComment": "Defines HTML headings",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "h2",
          "tagValue": "<h2></h2>",
          "TagComment": "Defines HTML headings",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "h3",
          "tagValue": "<h3></h3>",
          "TagComment": "Defines HTML headings",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "h4",
          "tagValue": "<h4></h4>",
          "TagComment": "Defines HTML headings",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "h5",
          "tagValue": "<h5></h5>",
          "TagComment": "Defines HTML headings",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "h6",
          "tagValue": "<h6></h6>",
          "TagComment": "Defines HTML headings",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "p",
          "tagValue": "<p></p>",
          "TagComment": "Defines a paragraph",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "br",
          "tagValue": "<br>",
          "TagComment": "Inserts a single line break",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "hr",
          "tagValue": "<hr>",
          "TagComment": "Defines a thematic change in the content",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "!--...--",
          "tagValue": "<!--...-->",
          "TagComment": "Defines a comment",
          "TagType": "Basic HTML"
        },
        {
          "tagName": "abbr",
          "tagValue": "<abbr></abbr>",
          "TagComment": "Defines an abbreviation or an acronym",
          "TagType": "Formatting"
        },
        {
          "tagName": "address",
          "tagValue": "<address></address>",
          "TagComment": "Defines contact information for the author/owner of a document/article",
          "TagType": "Formatting"
        },
        {
          "tagName": "b",
          "tagValue": "<b></b>",
          "TagComment": "Defines bold text",
          "TagType": "Formatting"
        },
        {
          "tagName": "bdi",
          "tagValue": "<bdi></bdi>",
          "TagComment": "Isolates a part of text that might be formatted in a different direction from other text outside it",
          "TagType": "Formatting"
        },
        {
          "tagName": "bdo",
          "tagValue": "<bdo></bdo>",
          "TagComment": "Overrides the current text direction",
          "TagType": "Formatting"
        },
        {
          "tagName": "blockquote",
          "tagValue": "<blockquote></blockquote>",
          "TagComment": "Defines a section that is quoted from another source",
          "TagType": "Formatting"
        },
        {
          "tagName": "cite",
          "tagValue": "<cite></cite>",
          "TagComment": "Defines the title of a work",
          "TagType": "Formatting"
        },
        {
          "tagName": "code",
          "tagValue": "<code></code>",
          "TagComment": "Defines a piece of computer code",
          "TagType": "Formatting"
        },
        {
          "tagName": "del",
          "tagValue": "<del></del>",
          "TagComment": "Defines text that has been deleted from a document",
          "TagType": "Formatting"
        },
        {
          "tagName": "dfn",
          "tagValue": "<dfn></dfn>",
          "TagComment": "Specifies a term that is going to be defined within the content",
          "TagType": "Formatting"
        },
        {
          "tagName": "em",
          "tagValue": "<em></em>",
          "TagComment": "Defines emphasized text",
          "TagType": "Formatting"
        },
        {
          "tagName": "i",
          "tagValue": "<i></i>",
          "TagComment": "Defines a part of text in an alternate voice or mood",
          "TagType": "Formatting"
        },
        {
          "tagName": "ins",
          "tagValue": "<ins></ins>",
          "TagComment": "Defines a text that has been inserted into a document",
          "TagType": "Formatting"
        },
        {
          "tagName": "kbd",
          "tagValue": "<kbd></kbd>",
          "TagComment": "Defines keyboard input",
          "TagType": "Formatting"
        },
        {
          "tagName": "mark",
          "tagValue": "<mark></mark>",
          "TagComment": "Defines marked/highlighted text",
          "TagType": "Formatting"
        },
        {
          "tagName": "meter",
          "tagValue": "<meter></meter>",
          "TagComment": "Defines a scalar measurement within a known range (a gauge)",
          "TagType": "Formatting"
        },
        {
          "tagName": "pre",
          "tagValue": "<pre></pre>",
          "TagComment": "Defines preformatted text",
          "TagType": "Formatting"
        },
        {
          "tagName": "progress",
          "tagValue": "<progress></progress>",
          "TagComment": "Represents the progress of a task",
          "TagType": "Formatting"
        },
        {
          "tagName": "q",
          "tagValue": "<q></q>",
          "TagComment": "Defines a short quotation",
          "TagType": "Formatting"
        },
        {
          "tagName": "rp",
          "tagValue": "<rp></rp>",
          "TagComment": "Defines what to show in browsers that do not support ruby annotations",
          "TagType": "Formatting"
        },
        {
          "tagName": "rt",
          "tagValue": "<rt></rt>",
          "TagComment": "Defines an explanation/pronunciation of characters (for East Asian typography)",
          "TagType": "Formatting"
        },
        {
          "tagName": "ruby",
          "tagValue": "<ruby></ruby>",
          "TagComment": "Defines a ruby annotation (for East Asian typography)",
          "TagType": "Formatting"
        },
        {
          "tagName": "s",
          "tagValue": "<s></s>",
          "TagComment": "Defines text that is no longer correct",
          "TagType": "Formatting"
        },
        {
          "tagName": "samp",
          "tagValue": "<samp></samp>",
          "TagComment": "Defines sample output from a computer program",
          "TagType": "Formatting"
        },
        {
          "tagName": "small",
          "tagValue": "<small></small>",
          "TagComment": "Defines smaller text",
          "TagType": "Formatting"
        },
        {
          "tagName": "strong",
          "tagValue": "<strong></strong>",
          "TagComment": "Defines important text",
          "TagType": "Formatting"
        },
        {
          "tagName": "sub",
          "tagValue": "<sub></sub>",
          "TagComment": "Defines subscripted text",
          "TagType": "Formatting"
        },
        {
          "tagName": "sup",
          "tagValue": "<sup></sup>",
          "TagComment": "Defines superscripted text",
          "TagType": "Formatting"
        },
        {
          "tagName": "template",
          "tagValue": "<template></template>",
          "TagComment": "Defines a container for content that should be hidden when the page loads",
          "TagType": "Formatting"
        },
        {
          "tagName": "time",
          "tagValue": "<time></time>",
          "TagComment": "Defines a specific time (or datetime)",
          "TagType": "Formatting"
        },
        {
          "tagName": "u",
          "tagValue": "<u></u>",
          "TagComment": "Defines some text that is unarticulated and styled differently from normal text",
          "TagType": "Formatting"
        },
        {
          "tagName": "var",
          "tagValue": "<var></var>",
          "TagComment": "Defines a variable",
          "TagType": "Formatting"
        },
        {
          "tagName": "wbr",
          "tagValue": "<wbr>",
          "TagComment": "Defines a possible line-break",
          "TagType": "Formatting"
        },
        {
          "tagName": "form",
          "tagValue": "<form></form>",
          "TagComment": "Defines an HTML form for user input",
          "TagType": "Forms and Input"
        },
        {
          "tagName": "input",
          "tagValue": "<input>",
          "TagComment": "Defines an input control",
          "TagType": "Forms and Input"
        },
        {
          "tagName": "textarea",
          "tagValue": "<textarea></textarea>",
          "TagComment": "Defines a multiline input control (text area)",
          "TagType": "Forms and Input"
        },
        {
          "tagName": "button",
          "tagValue": "<button></button>",
          "TagComment": "Defines a clickable button",
          "TagType": "Forms and Input"
        },
        {
          "tagName": "select",
          "tagValue": "<select></select>",
          "TagComment": "Defines a drop-down list",
          "TagType": "Forms and Input"
        },
        {
          "tagName": "optgroup",
          "tagValue": "<optgroup></optgroup>",
          "TagComment": "Defines a group of related options in a drop-down list",
          "TagType": "Forms and Input"
        },
        {
          "tagName": "option",
          "tagValue": "<option></option>",
          "TagComment": "Defines an option in a drop-down list",
          "TagType": "Forms and Input"
        },
        {
          "tagName": "label",
          "tagValue": "<label></label>",
          "TagComment": "Defines a label for an <input> element",
          "TagType": "Forms and Input"
        },
        {
          "tagName": "fieldset",
          "tagValue": "<fieldset></fieldset>",
          "TagComment": "Groups related elements in a form",
          "TagType": "Forms and Input"
        },
        {
          "tagName": "legend",
          "tagValue": "<legend></legend>",
          "TagComment": "Defines a caption for a <fieldset> element",
          "TagType": "Forms and Input"
        },
        {
          "tagName": "datalist",
          "tagValue": "<datalist></datalist>",
          "TagComment": "Specifies a list of pre-defined options for input controls",
          "TagType": "Forms and Input"
        },
        {
          "tagName": "output",
          "tagValue": "<output></output>",
          "TagComment": "Defines the result of a calculation",
          "TagType": "Forms and Input"
        },
        {
          "tagName": "iframe",
          "tagValue": "<iframe></iframe>",
          "TagComment": "Defines an inline frame",
          "TagType": "Frames"
        },
        {
          "tagName": "img",
          "tagValue": "<img>",
          "TagComment": "Defines an image",
          "TagType": "Images"
        },
        {
          "tagName": "map",
          "tagValue": "<map></map>",
          "TagComment": "Defines a client-side image map",
          "TagType": "Images"
        },
        {
          "tagName": "area",
          "tagValue": "<area>",
          "TagComment": "Defines an area inside an image map",
          "TagType": "Images"
        },
        {
          "tagName": "canvas",
          "tagValue": "<canvas></canvas>",
          "TagComment": "Used to draw graphics, on the fly, via scripting (usually JavaScript)",
          "TagType": "Images"
        },
        {
          "tagName": "figcaption",
          "tagValue": "<figcaption></figcaption>",
          "TagComment": "Defines a caption for a <figure> element",
          "TagType": "Images"
        },
        {
          "tagName": "figure",
          "tagValue": "<figure></figure>",
          "TagComment": "Specifies self-contained content",
          "TagType": "Images"
        },
        {
          "tagName": "picture",
          "tagValue": "<picture></picture>",
          "TagComment": "Defines a container for multiple image resources",
          "TagType": "Images"
        },
        {
          "tagName": "svg",
          "tagValue": "<svg></svg>",
          "TagComment": "Defines a container for SVG graphics",
          "TagType": "Images"
        },
        {
          "tagName": "audio",
          "tagValue": "<audio></audio>",
          "TagComment": "Defines sound content",
          "TagType": "Audio / Video"
        },
        {
          "tagName": "source",
          "tagValue": "<source>",
          "TagComment": "Defines multiple media resources for media elements (<video>, <audio> and <picture>)",
          "TagType": "Audio / Video"
        },
        {
          "tagName": "track",
          "tagValue": "<track>",
          "TagComment": "Defines text tracks for media elements (<video> and <audio>)",
          "TagType": "Audio / Video"
        },
        {
          "tagName": "video",
          "tagValue": "<video></video>",
          "TagComment": "Defines a video or movie",
          "TagType": "Audio / Video"
        },
        {
          "tagName": "a",
          "tagValue": "<a></a>",
          "TagComment": "Defines a hyperlink",
          "TagType": "Links"
        },
        {
          "tagName": "link",
          "tagValue": "<link>",
          "TagComment": "Defines the relationship between a document and an external resource (most used to link to style sheets)",
          "TagType": "Links"
        },
        {
          "tagName": "nav",
          "tagValue": "<nav></nav>",
          "TagComment": "Defines navigation links",
          "TagType": "Links"
        },
        {
          "tagName": "menu",
          "tagValue": "<menu></menu>",
          "TagComment": "Defines an alternative unordered list",
          "TagType": "Lists"
        },
        {
          "tagName": "ul",
          "tagValue": "<ul></ul>",
          "TagComment": "Defines an unordered list",
          "TagType": "Lists"
        },
        {
          "tagName": "ol",
          "tagValue": "<ol></ol>",
          "TagComment": "Defines an ordered list",
          "TagType": "Lists"
        },
        {
          "tagName": "li",
          "tagValue": "<li></li>",
          "TagComment": "Defines a list item",
          "TagType": "Lists"
        },
        {
          "tagName": "dl",
          "tagValue": "<dl></dl>",
          "TagComment": "Defines a description list",
          "TagType": "Lists"
        },
        {
          "tagName": "dt",
          "tagValue": "<dt></dt>",
          "TagComment": "Defines a term/name in a description list",
          "TagType": "Lists"
        },
        {
          "tagName": "dd",
          "tagValue": "<dd></dd>",
          "TagComment": "Defines a description of a term/name in a description list",
          "TagType": "Lists"
        },
        {
          "tagName": "table",
          "tagValue": "<table></table>",
          "TagComment": "Defines a table",
          "TagType": "Tables"
        },
        {
          "tagName": "caption",
          "tagValue": "<caption></caption>",
          "TagComment": "Defines a table caption",
          "TagType": "Tables"
        },
        {
          "tagName": "th",
          "tagValue": "<th></th>",
          "TagComment": "Defines a header cell in a table",
          "TagType": "Tables"
        },
        {
          "tagName": "tr",
          "tagValue": "<tr></tr>",
          "TagComment": "Defines a row in a table",
          "TagType": "Tables"
        },
        {
          "tagName": "td",
          "tagValue": "<td></td>",
          "TagComment": "Defines a cell in a table",
          "TagType": "Tables"
        },
        {
          "tagName": "thead",
          "tagValue": "<thead></thead>",
          "TagComment": "Groups the header content in a table",
          "TagType": "Tables"
        },
        {
          "tagName": "tbody",
          "tagValue": "<tbody></tbody>",
          "TagComment": "Groups the body content in a table",
          "TagType": "Tables"
        },
        {
          "tagName": "tfoot",
          "tagValue": "<tfoot></tfoot>",
          "TagComment": "Groups the footer content in a table",
          "TagType": "Tables"
        },
        {
          "tagName": "col",
          "tagValue": "<col>",
          "TagComment": "Specifies column properties for each column within a <colgroup> element",
          "TagType": "Tables"
        },
        {
          "tagName": "colgroup",
          "tagValue": "<colgroup></colgroup>",
          "TagComment": "Specifies a group of one or more columns in a table for formatting",
          "TagType": "Tables"
        },
        {
          "tagName": "style",
          "tagValue": "<style></style>",
          "TagComment": "🎨Defines style information for a document🎨",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "div",
          "tagValue": "<div></div>",
          "TagComment": "Defines a section in a document",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "span",
          "tagValue": "<span></span>",
          "TagComment": "Defines a section in a document",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "header",
          "tagValue": "<header></header>",
          "TagComment": "Defines a header for a document or section",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "hgroup",
          "tagValue": "<hgroup></hgroup>",
          "TagComment": "Defines a header and related content",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "footer",
          "tagValue": "<footer></footer>",
          "TagComment": "Defines a footer for a document or section",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "main",
          "tagValue": "<main></main>",
          "TagComment": "Specifies the main content of a document",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "section",
          "tagValue": "<section></section>",
          "TagComment": "Defines a section in a document",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "search",
          "tagValue": "<search></search>",
          "TagComment": "Defines a search section",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "article",
          "tagValue": "<article></article>",
          "TagComment": "Defines an article",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "aside",
          "tagValue": "<aside></aside>",
          "TagComment": "Defines content aside from the page content",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "details",
          "tagValue": "<details></details>",
          "TagComment": "Defines additional details that the user can view or hide",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "dialog",
          "tagValue": "<dialog></dialog>",
          "TagComment": "Defines a dialog box or window",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "summary",
          "tagValue": "<summary></summary>",
          "TagComment": "Defines a visible heading for a <details> element",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "data",
          "tagValue": "<data></data>",
          "TagComment": "Adds a machine-readable translation of a given content",
          "TagType": "Styles and Semantics"
        },
        {
          "tagName": "meta",
          "tagValue": "<meta>",
          "TagComment": "Defines metadata about an HTML document",
          "TagType": "Meta Info"
        },
        {
          "tagName": "base",
          "tagValue": "<base>",
          "TagComment": "Specifies the base URL/target for all relative URLs in a document",
          "TagType": "Meta Info"
        },
        {
          "tagName": "script",
          "tagValue": "<scrip></scrip>",
          "TagComment": "💻Defines a client-side script💻",
          "TagType": "Programming"
        },
        {
          "tagName": "noscript",
          "tagValue": "<noscript></noscript>",
          "TagComment": "Defines an alternate content for users that do not support client-side scripts",
          "TagType": "Programming"
        },
        {
          "tagName": "embed",
          "tagValue": "<embed></embed>",
          "TagComment": "Defines a container for an external (non-HTML) application",
          "TagType": "Programming"
        },
        {
          "tagName": "object",
          "tagValue": "<object></object>",
          "TagComment": "Defines an embedded object",
          "TagType": "Programming"
        },
        {
          "tagName": "param",
          "tagValue": "<param>",
          "TagComment": "Defines a parameter for an object",
          "TagType": "Programming"
        },
        {
          "tagName": "path",
          "tagValue": "<path>",
          "TagComment": "svg",
          "TagType": "svg"
        }
      ];


    function buildTable() {
      const tableBody = getElementById1('tagsTable').getElementsByTagName('tbody')[0];
      tags.forEach((tag, index) => {
        let row = tableBody.insertRow();
        row.onclick = function (event) { chooseTag(index, event); };

        let tagNameCell = row.insertCell(0);
        let tagValueCell = row.insertCell(1);
        let tagTypeCell = row.insertCell(2);
        let tagCommentCell = row.insertCell(3);

        tagNameCell.textContent = tag.tagName;
        tagValueCell.textContent = tag.tagValue;
        tagTypeCell.textContent = tag.TagType;
        tagCommentCell.textContent = tag.TagComment;
      });
    }
    function filterTable(column) {
      let input, filter, table, tr, td, i, txtValue;
      input = getElementById1("tagsTable").getElementsByTagName("thead")[0].getElementsByTagName("input")[column];
      filter = input.value.toUpperCase();
      table = getElementById1("tagsTable");
      tr = table.getElementsByTagName("tr");

      for (i = 2; i < tr.length; i++) {
        td = tr[i].getElementsByTagName("td")[column];
        if (td) {
          txtValue = td.textContent || td.innerText;
          if (txtValue.toUpperCase().indexOf(filter) > -1) {
            tr[i].style.display = "";
          } else {
            tr[i].style.display = "none";
          }
        }
      }
    }
    function chooseTag(index, event) {
      console.log('in')
      console.log(event)
      let chosenTag = tags[index];
      //alert("Chosen Tag Name: " + chosenTag.tagName + "\nChosen Tag Value: " + chosenTag.tagValue);

      // Get the fieldset attributes
      const fieldset = event.currentTarget.closest('fieldset');
      if (fieldset) {
        const fieldsetId = fieldset.id;
        const fieldsetAction = fieldset.getAttribute('action');
        console.log("Fieldset ID:", fieldsetId);
        console.log("Fieldset Action:", fieldsetAction);
        const splited = fieldsetId.split(';')
        splited.shift()
        splited.join(';')
        const el =
        {
          time: (new Date()).getTime(),
          action: fieldsetAction,
          target_element: splited.join(';'),

        }
        if (fieldsetAction === 'ChangeTag' || fieldsetAction === 'ChangeTagForCopies') {
          el.tag_change = chosenTag.tagName
        }

        else {
          el.inserted_element = { type: 'tag', tagValue: chosenTag.tagValue, tagName: chosenTag.tagName, id: generateUUID() }
        }
        pushAction(el)
        fieldset.remove()
      }
    }

    window.onload = buildTable;    </script>
  </code-builder>

  <style>
    .highlight-left-border-red {
      border-left-color: blue;
      transition: 0.1s ease;

    }

    .highlight-red {
      border-color: blue;
      transition: 0.1s ease;
      background-color: rgb(88, 105, 255)
    }


    .highlight-left-border-blue {
      border-left-color: red;


    }

    .highlight-blue {
      border-color: red;
      transition: 0.1s ease;
      background-color: rgb(255, 88, 88)
    }
  </style>
  <script>
    function mouseOverTree(e) {
      // Highlight this button in red
      e.target.classList.add('highlight-red');

      let parentFieldset = e.target.closest('[data-element="code-tree-tag"]');

      // Highlight the left border of the parent fieldset in red
      if (parentFieldset) {
        parentFieldset.classList.add('highlight-left-border-red');
      }

      // Highlight the left border of sibling fieldsets and their direct child buttons in red
      Array.from(parentFieldset.parentElement.children).forEach(sibling => {
        if (sibling !== parentFieldset && sibling.getAttribute('data-element') === 'code-tree-tag') {
          sibling.classList.add('highlight-left-border-red');
          Array.from(sibling.children).forEach(child => {
            if (child.tagName === 'BUTTON' && child.getAttribute('data-element') === 'code-tree-show-hide-button') {
              child.classList.add('highlight-red');
            }
          });
        }
      });

      // Highlight the left border and buttons of direct child fieldsets of parentFieldset in blue
      Array.from(parentFieldset.children).forEach(child => {
        if (child.tagName === 'FIELDSET' && child.getAttribute('data-element') === 'code-tree-tag') {
          child.classList.add('highlight-left-border-blue');
          Array.from(child.children).forEach(grandchild => {
            if (grandchild.tagName === 'BUTTON' && grandchild.getAttribute('data-element') === 'code-tree-show-hide-button') {
              grandchild.classList.add('highlight-blue');
            }
          });
        }
      });
    }
    function mouseOutTree(e) {
      let parentFieldset = e.target.closest('[data-element="code-tree-tag"]');

      // Remove the red and blue highlights
      e.target.classList.remove('highlight-red');
      if (parentFieldset) {
        parentFieldset.classList.remove('highlight-left-border-red');
      }
      Array.from(parentFieldset.parentElement.children).forEach(sibling => {
        if (sibling !== parentFieldset && sibling.getAttribute('data-element') === 'code-tree-tag') {
          sibling.classList.remove('highlight-left-border-red');
          Array.from(sibling.children).forEach(child => {
            if (child.tagName === 'BUTTON' && child.getAttribute('data-element') === 'code-tree-show-hide-button') {
              child.classList.remove('highlight-red');
            }
          });
        }
      });
      Array.from(parentFieldset.children).forEach(child => {
        if (child.tagName === 'FIELDSET' && child.getAttribute('data-element') === 'code-tree-tag') {
          child.classList.remove('highlight-left-border-blue');
          Array.from(child.children).forEach(grandchild => {
            if (grandchild.tagName === 'BUTTON' && grandchild.getAttribute('data-element') === 'code-tree-show-hide-button') {
              grandchild.classList.remove('highlight-blue');
            }
          });
        }
      });
    }
    querySelectorAll1('button[data-element="code-tree-show-hide-button"]').forEach(button => {
      button.addEventListener('mouseover', mouseOverTree);

      button.addEventListener('mouseout', mouseOutTree);
    });
  </script>
  <!-- dublicate for components-->
  <script>
    function mouseOver(e) {
      // Highlight this button in red
      e.target.classList.add('highlight-red');

      let parentFieldset = e.target.closest('[data-element="component-tree-tag"]');

      // Highlight the left border of the parent fieldset in red
      if (parentFieldset) {
        parentFieldset.classList.add('highlight-left-border-red');
      }

      // Highlight the left border of sibling fieldsets and their direct child buttons in red
      Array.from(parentFieldset.parentElement.children).forEach(sibling => {
        if (sibling !== parentFieldset && sibling.getAttribute('data-element') === 'component-tree-tag') {
          sibling.classList.add('highlight-left-border-red');
          Array.from(sibling.children).forEach(child => {
            if (child.tagName === 'BUTTON' && child.getAttribute('data-element') === 'component-tree-show-hide-button') {
              child.classList.add('highlight-red');
            }
          });
        }
      });

      // Highlight the left border and buttons of direct child fieldsets of parentFieldset in blue
      Array.from(parentFieldset.children).forEach(child => {
        if (child.tagName === 'FIELDSET' && child.getAttribute('data-element') === 'component-tree-tag') {
          child.classList.add('highlight-left-border-blue');
          Array.from(child.children).forEach(grandchild => {
            if (grandchild.tagName === 'BUTTON' && grandchild.getAttribute('data-element') === 'component-tree-show-hide-button') {
              grandchild.classList.add('highlight-blue');
            }
          });
        }
      });
    }
    function mouseOut(e) {
      let parentFieldset = e.target.closest('[data-element="component-tree-tag"]');

      // Remove the red and blue highlights
      e.target.classList.remove('highlight-red');
      if (parentFieldset) {
        parentFieldset.classList.remove('highlight-left-border-red');
      }
      Array.from(parentFieldset.parentElement.children).forEach(sibling => {
        if (sibling !== parentFieldset && sibling.getAttribute('data-element') === 'component-tree-tag') {
          sibling.classList.remove('highlight-left-border-red');
          Array.from(sibling.children).forEach(child => {
            if (child.tagName === 'BUTTON' && child.getAttribute('data-element') === 'component-tree-show-hide-button') {
              child.classList.remove('highlight-red');
            }
          });
        }
      });
      Array.from(parentFieldset.children).forEach(child => {
        if (child.tagName === 'FIELDSET' && child.getAttribute('data-element') === 'component-tree-tag') {
          child.classList.remove('highlight-left-border-blue');
          Array.from(child.children).forEach(grandchild => {
            if (grandchild.tagName === 'BUTTON' && grandchild.getAttribute('data-element') === 'component-tree-show-hide-button') {
              grandchild.classList.remove('highlight-blue');
            }
          });
        }
      });

    }
    querySelectorAll1('button[data-element="component-tree-show-hide-button"]').forEach(button => {
      button.addEventListener('mouseover', mouseOver);

      button.addEventListener('mouseout', mouseOut);

    });

  </script>


  <script>
    /*
    document.addEventListener('DOMContentLoaded', function () {
      var textarea = getElementById1('code-tree-inner-html-receive-textarea');

      textarea.addEventListener('input', function (e) {
        // Expand height
        e.target.style.height = 'auto';
        e.target.style.height = (e.target.scrollHeight) + 'px';

        // Expand width
        var mirrorDiv = getElementById1('mirror-div');
        if (!mirrorDiv) {
          mirrorDiv = document.createElement('div');
          mirrorDiv.id = 'mirror-div';
          document.body.appendChild(mirrorDiv);
        }

        mirrorDiv.style.display = 'inline-block';
        mirrorDiv.textContent = e.target.value.replace(/\n/g, '<br/>');
        e.target.style.width = Math.min(e.target.parentElement.offsetWidth, mirrorDiv.offsetWidth + 10) + 'px'; // 10px for some padding
        mirrorDiv.style.display = 'none';
      });
    });
    */
  </script>


  <script src="js/left-panel.js" async=""></script>